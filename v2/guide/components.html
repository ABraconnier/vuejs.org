

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Composants — Vue.js</title>
    <meta charset="utf-8">
    <meta name="description" content="Vue.js - Le Framework JavaScript Évolutif">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <link rel="alternate" hreflang="x-default" href="https://vuejs.org/v2/guide/components.html">
    <link rel="alternate" hreflang="zh" href="https://cn.vuejs.org/v2/guide/components.html">
    <link rel="alternate" hreflang="ja" href="https://jp.vuejs.org/v2/guide/components.html">
    <link rel="alternate" hreflang="ru" href="https://ru.vuejs.org/v2/guide/components.html">
    <link rel="alternate" hreflang="ko" href="https://kr.vuejs.org/v2/guide/components.html">
    <link rel="alternate" hreflang="pt-BR" href="https://br.vuejs.org/v2/guide/components.html">
    <link rel="alternate" hreflang="fr" href="https://fr.vuejs.org/v2/guide/components.html">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Composants — Vue.js">
    <meta property="og:description" content="Vue.js - Le Framework JavaScript Évolutif">
    <meta property="og:image" content="https://vuejs.org//images/logo.png">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Composants — Vue.js">
    <meta name="twitter:description" content="Vue.js - Le Framework JavaScript Évolutif">
    <meta name="twitter:image" content="https://vuejs.org/images/logo.png">

    <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/icons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png">
    <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
    <link rel="icon" href="/images/logo.png" type="image/png">

    <meta name="msapplication-TileColor" content="#4fc08d">
    <meta name="theme-color" content="#4fc08d">

    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="manifest" href="/manifest.json">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Dosis:500&text=Vue.js' rel='stylesheet' type='text/css'>

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    <link rel="stylesheet" href="/css/page.css">

    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="/js/vue.js"></script>
    <script>window.PAGE_TYPE = "guide"</script>

    <!-- ga -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46852172-1', 'vuejs.org');
      ga('send', 'pageview');
    </script>

    <!-- vimeo analytics -->
    <script type="text/javascript" defer="defer" src="https://extend.vimeocdn.com/ga/72160148.js"></script>
  </head>
  <body class="docs">
    <div id="mobile-bar" >
      <a class="menu-button"></a>
      <a class="logo" href="/"></a>
    </div>
    <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png">
    <span>Vue.js</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">Doc</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/v2/guide/" class="nav-link current">Guide</a></li>
      <li><a href="/v2/api/" class="nav-link">API</a></li>
      <li><a href="/v2/style-guide/" class="nav-link">Conventions</a></li>
      <li><a href="/v2/examples/" class="nav-link">Exemples</a></li>
      <li><a href="/v2/cookbook/" class="nav-link">Tutoriels</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Écosystème</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Aide</h4></li>
    <li><ul>
      <li><a href="https://forum.vuejs.org/c/french" class="nav-link" target="_blank">Forum</a></li>
      <li><a href="https://discordapp.com/channels/325477692906536972/360669119948783616" class="nav-link" target="_blank">Chat</a></li>
    </ul></li>
    <li><h4>Outils</h4></li>
    <li>
      <ul>
        <li><a href="https://github.com/vuejs/vue-devtools" class="nav-link" target="_blank">Devtools (En)</a></li>
        <li><a href="https://vuejs-templates.github.io/webpack" class="nav-link" target="_blank">Template webpack (En)</a></li>
        <li><a href="https://vue-loader.vuejs.org" class="nav-link" target="_blank">Vue Loader (En)</a></li>
      </ul>
    </li>
    <li><h4>Bibliothèques officielles</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
      <li><a href="https://ssr.vuejs.org/" class="nav-link" target="_blank">Vue Server Renderer</a></li>
    </ul></li>
    <li><h4>Infos</h4></li>
    <li><ul>
      <li><a href="https://news.vuejs.org" class="nav-link" target="_blank">Actualités (En)</a></li>
      <li><a href="https://github.com/vuejs/roadmap" class="nav-link" target="_blank">Plans futurs (En)</a></li>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter (En)</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Blog (En)</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">Offres d'emploi (En)</a></li>
    </ul></li>
    <li><h4>Liste de ressources</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Dépôt officiel (En)</a></li>
      <li><a href="https://curated.vuejs.org/" class="nav-link" target="_blank">Curation Vue (En)</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue (En)</a></li>
    </ul></li>
  </ul>
</li>

<li>
  <a href="/v2/guide/team.html" class="nav-link team">Équipe</a>
</li>
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Soutien</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">Don ponctuel</a></li>
      <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Soutien récurrent</a></li>
      <li><a href="https://vue.threadless.com" target="_blank" class="nav-link">La boutique</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Langues</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://br.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://ru.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Русский</a></li>
    <li><a href="https://vi.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Tiếng Việt</a></li>
  </ul>
</li>


  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
          
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li>
<li class="nav-dropdown-container learn">
  <a class="nav-link current">Doc</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/v2/guide/" class="nav-link current">Guide</a></li>
      <li><a href="/v2/api/" class="nav-link">API</a></li>
      <li><a href="/v2/style-guide/" class="nav-link">Conventions</a></li>
      <li><a href="/v2/examples/" class="nav-link">Exemples</a></li>
      <li><a href="/v2/cookbook/" class="nav-link">Tutoriels</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Écosystème</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Aide</h4></li>
    <li><ul>
      <li><a href="https://forum.vuejs.org/c/french" class="nav-link" target="_blank">Forum</a></li>
      <li><a href="https://discordapp.com/channels/325477692906536972/360669119948783616" class="nav-link" target="_blank">Chat</a></li>
    </ul></li>
    <li><h4>Outils</h4></li>
    <li>
      <ul>
        <li><a href="https://github.com/vuejs/vue-devtools" class="nav-link" target="_blank">Devtools (En)</a></li>
        <li><a href="https://vuejs-templates.github.io/webpack" class="nav-link" target="_blank">Template webpack (En)</a></li>
        <li><a href="https://vue-loader.vuejs.org" class="nav-link" target="_blank">Vue Loader (En)</a></li>
      </ul>
    </li>
    <li><h4>Bibliothèques officielles</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
      <li><a href="https://ssr.vuejs.org/" class="nav-link" target="_blank">Vue Server Renderer</a></li>
    </ul></li>
    <li><h4>Infos</h4></li>
    <li><ul>
      <li><a href="https://news.vuejs.org" class="nav-link" target="_blank">Actualités (En)</a></li>
      <li><a href="https://github.com/vuejs/roadmap" class="nav-link" target="_blank">Plans futurs (En)</a></li>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter (En)</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Blog (En)</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">Offres d'emploi (En)</a></li>
    </ul></li>
    <li><h4>Liste de ressources</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Dépôt officiel (En)</a></li>
      <li><a href="https://curated.vuejs.org/" class="nav-link" target="_blank">Curation Vue (En)</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue (En)</a></li>
    </ul></li>
  </ul>
</li>

<li>
  <a href="/v2/guide/team.html" class="nav-link team">Équipe</a>
</li>
<li class="nav-dropdown-container support-vue">
  <a href="/support-vuejs/" class="nav-link">Soutien</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a href="/support-vuejs/#One-time-Donations" class="nav-link">Don ponctuel</a></li>
      <li><a href="/support-vuejs/#Recurring-Pledges" class="nav-link">Soutien récurrent</a></li>
      <li><a href="https://vue.threadless.com" target="_blank" class="nav-link">La boutique</a></li>
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">Langues</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://br.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://ru.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Русский</a></li>
    <li><a href="https://vi.vuejs.org/v2/guide/components.html" class="nav-link" target="_blank">Tiếng Việt</a></li>
  </ul>
</li>


    </ul>
    <div class="list">
      <div id="sidebar-sponsors-special">
  <div class="main-sponsor">
    <span>Special Sponsors</span>
    <div>
    <a href="https://stdlib.com" target="_blank" class="logo">
      <img src="/images/stdlib.png">
    </a>
    <a href="https://www.bitsrc.io/?utm_source=vue&utm_medium=vue&utm_campaign=vue&utm_term=vue&utm_content=vue" target="_blank" class="logo">
      <img src="/images/bit-wide.png">
    </a>
    </div>
  </div>
</div>

<div id="sidebar-sponsors-platinum">
  <div class="main-sponsor">
    <span>Patreon Sponsors</span>
    <div>
    <a href="http://tooltwist.com/" target="_blank" class="logo">
      <img src="/images/tooltwist.png">
    </a>
    <a href="https://vueschool.io/?utm_source=Vuejs.org&utm_medium=Banner&utm_campaign=Sponsored%20Banner&utm_content=V1" target="_blank" class="logo">
      <img src="/images/vueschool.png">
    </a>
    <a href="https://vehikl.com/" target="_blank" class="logo">
      <img src="/images/vehikl.png">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    Devenez un sponsor
  </a>
</div>

      
        <h2>
          
          Guide
          
            <select class="version-select">
              <option value="SELF" selected>2.x</option>
              <option value="v1">1.0</option>
              <option value="012">0.12</option>
              <option value="011">0.11</option>
            </select>
          
        </h2>
        <ul class="menu-root">
  
    
    
      
        <li><h3>Essentiel</h3></li>
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/installation.html" class="sidebar-link">Installation</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/index.html" class="sidebar-link">Introduction</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/instance.html" class="sidebar-link">L'instance de Vue</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/syntax.html" class="sidebar-link">Syntaxe de template</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/computed.html" class="sidebar-link">Propriétés calculées et observateurs</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/class-and-style.html" class="sidebar-link">Liaisons de classes et de styles</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/conditional.html" class="sidebar-link">Rendu conditionnel</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/list.html" class="sidebar-link">Rendu de liste</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/events.html" class="sidebar-link">Gestion des évènements</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/forms.html" class="sidebar-link">Liaisons sur les champs de formulaire</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/components.html" class="sidebar-link current">Composants</a>
    </li>
  
    
    
      
      
        <li><h3>Composants en détail</h3></li>
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/components-registration.html" class="sidebar-link">Component Registration</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/components-props.html" class="sidebar-link">Props</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/components-custom-events.html" class="sidebar-link">Événements personnalisés</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/components-slots.html" class="sidebar-link">Slots</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/components-dynamic-async.html" class="sidebar-link">Composants dynamiques et asynchrones</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/components-edge-cases.html" class="sidebar-link">Gérer les cas limites</a>
    </li>
  
    
    
      
      
      
        <li><h3>Transitions & animation</h3></li>
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/transitions.html" class="sidebar-link">Transitions d'entrée, de sortie et de liste</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/transitioning-state.html" class="sidebar-link">Transitions d'état</a>
    </li>
  
    
    
      
      
      
      
        <li><h3>Réusabilité & composition</h3></li>
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/mixins.html" class="sidebar-link">Mixins</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/custom-directive.html" class="sidebar-link">Directives personnalisées</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/render-function.html" class="sidebar-link">Fonctions de rendu et JSX</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/plugins.html" class="sidebar-link">Plugins</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/filters.html" class="sidebar-link">Filtres</a>
    </li>
  
    
    
      
      
      
      
      
        <li><h3>Outils</h3></li>
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/deployment.html" class="sidebar-link">Déploiement en production</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/single-file-components.html" class="sidebar-link">Composants monofichiers</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/unit-testing.html" class="sidebar-link">Tests unitaires</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/typescript.html" class="sidebar-link">Support de TypeScript</a>
    </li>
  
    
    
      
      
      
      
      
      
        <li><h3>Évolutions</h3></li>
      
      
      
      
    
    <li>
      <a href="/v2/guide/routing.html" class="sidebar-link">Routage</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/state-management.html" class="sidebar-link">Gestion de l'état</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/ssr.html" class="sidebar-link">Rendu côté serveur</a>
    </li>
  
    
    
      
      
      
      
      
      
      
        <li><h3>Mécanismes</h3></li>
      
      
      
    
    <li>
      <a href="/v2/guide/reactivity.html" class="sidebar-link">Réactivité dans le détail</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
        <li><h3>Migration</h3></li>
      
      
    
    <li>
      <a href="/v2/guide/migration.html" class="sidebar-link">Migration depuis Vue 1.x</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/migration-vue-router.html" class="sidebar-link">Migration depuis Vue Router 0.7.x</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/migration-vuex.html" class="sidebar-link">Migration depuis Vuex 0.6.x à 1.0</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
        <li><h3>Meta</h3></li>
      
    
    <li>
      <a href="/v2/guide/comparison.html" class="sidebar-link">Comparaison avec les autres frameworks</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/join.html" class="sidebar-link">Rejoignez la communauté Vue.js !</a>
    </li>
  
    
    
      
      
      
      
      
      
      
      
      
    
    <li>
      <a href="/v2/guide/team.html" class="sidebar-link">Rencontrer l'équipe</a>
    </li>
  
</ul>

      
    </div>
  </div>
</div>


<div class="content guide with-sidebar components-guide">
  
    
      <div id="ad">
  <script>
    (function () {
      var s = document.createElement('script')
      s.setAttribute('async', '')
      s.src = '//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=vuejs'
      s.id = '_carbonads_js'
      document.getElementById('ad').appendChild(s)
    })()
  </script>
</div>

    
  
  
    <h1>Composants</h1>
  
  
    <h2 id="Les-composants-qu’est-ce-que-c’est"><a href="#Les-composants-qu’est-ce-que-c’est" class="headerlink" title="Les composants, qu’est-ce que c’est ?"></a>Les composants, qu’est-ce que c’est ?</h2><p>Les composants sont l’une des plus puissantes fonctionnalités de Vue. Ils vous permettent d’étendre les éléments de base du HTML pour encapsuler du code réutilisable. À un haut niveau, les composants sont des éléments personnalisables auxquels le compilateur de Vue attache un comportement. Dans certains cas, ils peuvent aussi apparaitre comme des éléments HTML natifs étendus avec l’attribut spécial <code>is</code>.</p>
<p>Tous les composants Vue sont également des instances de Vue. Ils acceptent le même objet d’options (à l’exception de quelques options spécifiques à l’instance racine) et fournissent les mêmes hooks de cycle de vie.</p>
<h2 id="Utilisation-des-composants"><a href="#Utilisation-des-composants" class="headerlink" title="Utilisation des composants"></a>Utilisation des composants</h2><h3 id="Inscription-globale"><a href="#Inscription-globale" class="headerlink" title="Inscription globale"></a>Inscription globale</h3><p>Nous avons appris dans les sections précédentes que nous pouvions créer une nouvelle instance de Vue avec :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define a new component called button-counter</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Pour inscrire un composant global, vous pouvez utiliser <code>Vue.component(tagName, options)</code>. Par exemple :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p class="tip">Notez que Vue ne vous force pas à respecter les <a href="https://www.w3.org/TR/custom-elements/#concepts" target="_blank" rel="noopener">règles du W3C</a> en ce qui concerne les noms de balises personnalisées (tout en minuscules, obligation de contenir un trait d’union) bien que suivre cette convention est considéré comme une bonne pratique.</p>

<p>Une fois inscrit, un composant peut être utilisé dans le template d’une instance en tant qu’élément personnalisé, <code>&lt;my-component&gt;&lt;/my-component&gt;</code>. Assurez-vous que le composant soit inscrit <strong>avant</strong> l’instanciation de l’instance racine de Vue. Voici un exemple complet :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// inscrire</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;Un composant personnalisé !&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// créer une instance racine</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Ce qui donnera comme rendu :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Un composant personnalisé !<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div id="components-demo" class="demo">
  <button-counter></button-counter>
</div>
<script>
Vue.component('my-component', {
  template: '<div>Un composant personnalisé !</div>'
})
new Vue({ el: '#components-demo' })
</script>

<h3 id="Inscription-locale"><a href="#Inscription-locale" class="headerlink" title="Inscription locale"></a>Inscription locale</h3><p>Vous n’êtes pas obligé d’inscrire chaque composant de manière globale. Vous pouvez rendre un composant disponible dans la portée d’un(e) autre composant/instance en l’inscrivant avec l’option <code>components</code> lors de l’instanciation :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;Un composant personnalisé !&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; ne sera disponible que dans le template parent</span></span><br><span class="line">    <span class="string">'my-component'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>La même encapsulation s’applique pour les autres fonctionnalités de Vue pouvant être inscrites, comme les directives.</p>
<h3 id="Limitations-de-l’analyse-d’un-template-a-partir-du-DOM"><a href="#Limitations-de-l’analyse-d’un-template-a-partir-du-DOM" class="headerlink" title="Limitations de l’analyse d’un template à partir du DOM"></a>Limitations de l’analyse d’un template à partir du DOM</h3><p>Quand vous utilisez le DOM en tant que template (par ex. : en utilisant l’option <code>el</code> pour monter un élément avec du contenu existant), vous êtes sujet à plusieurs restrictions dépendantes de la façon dont fonctionne le HTML, car Vue peut uniquement récupérer le contenu du template <strong>après</strong> qu’il ait été analysé et normalisé. Des éléments tels que <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> et <code>&lt;select&gt;</code> ont notamment des restrictions sur les éléments que l’on peut trouver à l’intérieur, et plusieurs éléments comme <code>&lt;option&gt;</code> ne peuvent apparaître qu’à l’intérieur de certains éléments.</p>
<p>Ceci est problématique quand on utilise des composants personnalisés avec des éléments qui ont ces restrictions, par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-row</span>&gt;</span>...<span class="tag">&lt;/<span class="name">my-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Le composant personnalisé <code>&lt;my-row&gt;</code> sera évalué comme du contenu invalide, ce qui causera des erreurs dans les éventuels rendus en sortie. Une solution de contournement est d’utiliser l’attribut spécial <code>is</code> :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Il est à noter que ces limitations n’existent pas si vous utilisez des templates sous forme de chaine de caractères en provenance d’une des sources suivantes</strong> :</p>
<ul>
<li>les balises <code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li>les templates de chaine de caractères littérales en JavaScript</li>
<li>les composants <code>.vue</code></li>
</ul>
<p>Donc, préférez l’utilisation des templates de chaine de caractères lorsque c’est possible.</p>
<h3 id="data-doit-etre-une-fonction"><a href="#data-doit-etre-une-fonction" class="headerlink" title="data doit être une fonction"></a><code>data</code> doit être une fonction</h3><p>La plupart des options qui peuvent être passées dans le constructeur de Vue peuvent être utilisées dans un composant, avec un cas particulier : <code>data</code> doit être une fonction. En fait, si vous essayez ça :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'bonjour'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Alors Vue s’arrêtera et lancera des avertissements dans la console, vous indiquant que <code>data</code> doit être une fonction pour les instances de composant. Cependant, il serait bien de comprendre pourquoi cette règle existe, alors trichons.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'simple-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  <span class="comment">// data est techniquement une fonction, donc Vue ne va</span></span><br><span class="line">  <span class="comment">// pas se plaindre, mais nous allons retourner la même</span></span><br><span class="line">  <span class="comment">// référence d'objet pour chaque instance de composant</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div id="components-demo2" class="demo">
  <button-counter></button-counter>
  <button-counter></button-counter>
  <button-counter></button-counter>
</div>
<script>
new Vue({ el: '#components-demo2' })
</script>

<p>Puisque nos trois instances de composant partagent le même objet <code>data</code>, l’incrémentation d’un compteur les incrémentera tous ! Aie. Corrigeons cela en retournant un nouvel objet de données :</p>
<h3 id="data-Must-Be-a-Function"><a href="#data-Must-Be-a-Function" class="headerlink" title="data Must Be a Function"></a><code>data</code> Must Be a Function</h3><p>When we defined the <code>&lt;button-counter&gt;</code> component, you may have noticed that <code>data</code> wasn’t directly provided an object, like this:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead, <strong>a component’s <code>data</code> option must be a function</strong>, so that each instance can maintain an independent copy of the returned data object:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Maintenant tous nos compteurs ont leur propre état interne :</p>

<div id="components-demo3" class="demo">
  <button-counter2></button-counter2>
  <button-counter2></button-counter2>
  <button-counter2></button-counter2>
</div>
<script>
var buttonCounter2Data = {
  count: 0
}
Vue.component('button-counter2', {
  data: function () {
    return buttonCounter2Data
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})
new Vue({ el: '#components-demo3' })
</script>

<h3 id="Composition-de-composants"><a href="#Composition-de-composants" class="headerlink" title="Composition de composants"></a>Composition de composants</h3><p>Les composants sont destinés à être utilisés ensemble, le plus souvent dans une relation parent-enfant : le composant A peut utiliser le composant B dans son propre template. Ils vont inévitablement avoir besoin de communiquer les uns avec les autres : le parent peut avoir besoin de passer des données à l’enfant, et l’enfant peut avoir besoin d’informer le parent que quelque chose s’est produit à l’intérieur. Cependant, il est également très important de garder le parent et l’enfant aussi découplés que possible via une interface clairement définie. Cela assure que le code de chaque composant peut être écrit de manière relativement isolée, cela les rend plus maintenables et potentiellement plus simples à réutiliser.</p>
<p>Dans Vue.js, la relation parent-enfant peut être résumée ainsi : <strong>descente de props, remontée d’évènements</strong>. Le parent passe les données à l’enfant via les <strong>props</strong>, et l’enfant envoie des messages à son parent via les <strong>évènements</strong>. Voyons comment cela fonctionne ci-dessous.</p>
<p>For example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.</p>
<p>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: <strong>global</strong> and <strong>local</strong>. So far, we’ve only registered components globally, using <code>Vue.component</code>:</p>
<h3 id="Passer-des-donnees-avec-props"><a href="#Passer-des-donnees-avec-props" class="headerlink" title="Passer des données avec props"></a>Passer des données avec props</h3><p>Chaque instance de composant a sa propre <strong>portée isolée</strong>. Cela signifie qu’on ne peut (et ne devrait) pas directement référencer des données du parent dans un template de composant enfant. Les données doivent être passées aux composants enfants en utilisant <strong>props</strong>.</p>
<p>Une prop est un attribut personnalisé permettant de passer des informations depuis des composants parents. Un composant enfant a besoin de déclarer explicitement quelles sont les props qu’il s’attend à recevoir en utilisant <a href="../api/#props">l’option <code>props</code></a> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// déclarer les props</span></span><br><span class="line">  props: [<span class="string">'message'</span>],</span><br><span class="line">  <span class="comment">// tout comme un élément de `data`, une prop peut être utilisée à l'intérieur de templates</span></span><br><span class="line">  <span class="comment">// et est également disponible dans l'instance via `this.message`</span></span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Alors nous pouvons lui passer une simple chaine de caractères comme suit :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">"bonjour !"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Résultat :</p>

<div id="prop-example-1" class="demo">
  <child message="bonjour !"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['message'],
      template: '<span>{{ message }}</span>'
    }
  }
})
</script>

<p>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a <code>props</code> option:</p>
<p>Les attributs HTML sont insensibles à la casse, donc quand vous utilisez des templates qui ne sont pas des chaines de caractères, le nom de la prop en camelCase a besoin de son équivalent en kebab-case (délimité par des traits d’union) :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// camelCase en JavaScript</span></span><br><span class="line">  props: [<span class="string">'myMessage'</span>],</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- kebab-case en HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">my-message</span>=<span class="string">"bonjour !"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Encore une fois, si vous utilisez les templates sous forme de chaine de caractères, ces limitations ne s’appliquent pas.</p>
<h3 id="Props-dynamiques"><a href="#Props-dynamiques" class="headerlink" title="Props dynamiques"></a>Props dynamiques</h3><p>Tout comme la liaison d’un attribut ordinaire avec une expression, nous pouvons aussi utiliser <code>v-bind</code> pour dynamiquement lier les props aux données de leurs parents. À chaque fois que les données sont mises à jour dans le parent, elles seront également mises à jour dans l’enfant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"prop-example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"parentMsg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#prop-example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMsg: <span class="string">'Message venant du parent'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Vous pouvez aussi utiliser la syntaxe abrégée pour <code>v-bind</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Résultat :</p>

<div id="blog-post-demo" class="demo">
  <blog-post1 title="My journey with Vue"></blog-post1>
  <blog-post1 title="Blogging with Vue"></blog-post1>
  <blog-post1 title="Why Vue is so fun"></blog-post1>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Message venant du parent'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{ myMessage }}</span>'
    }
  }
})
new Vue({ el: '#blog-post-demo' })
</script>

<p>Si vous souhaitez passer toutes les propriétés dans un objet en tant que props, vous devez utiliser <code>v-bind</code> sans arguments  (<code>v-bind</code> au lieu de <code>v-bind:prop-name</code>). Par exemple, avec un objet <code>todo</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">todo: &#123;</span><br><span class="line">  text: <span class="string">'Apprendre Vue'</span>,</span><br><span class="line">  isComplete: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alors :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-bind</span>=<span class="string">"todo"</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Est équivalent à :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-item</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:text</span>=<span class="string">"todo.text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:is-complete</span>=<span class="string">"todo.isComplete"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Litterale-vs-Dynamique"><a href="#Litterale-vs-Dynamique" class="headerlink" title="Littérale vs. Dynamique"></a>Littérale vs. Dynamique</h3><p>Une erreur répandue chez les débutants est d’essayer de passer un nombre en utilisant la syntaxe littérale :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ceci passe une simple chaine de caractères "1" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Cependant, puisque c’est une prop littérale, sa valeur est passée en tant que simple chaine de caractères <code>&quot;1&quot;</code> au lieu d’être un nombre. Si nous voulons passer un nombre JavaScript, nous avons besoin d’utiliser <code>v-bind</code> ainsi sa valeur est évaluée en tant qu’expression JavaScript :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ceci passe un nombre --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Flux-de-donnees-unidirectionnel"><a href="#Flux-de-donnees-unidirectionnel" class="headerlink" title="Flux de données unidirectionnel"></a>Flux de données unidirectionnel</h3><p>Toutes les props forment une liaison <strong>descendante unidirectionnelle</strong> entre la propriété de l’enfant et celle du parent : quand la propriété parente est mise à jour, cela est signalé à l’enfant, mais pas dans l’autre sens. Cela empêche les composants enfants de modifier accidentellement l’état du parent, ce qui rendrait le flux de données de votre application difficile à appréhender.</p>
<p>De plus, chaque fois que le composant parent est mis à jour, toutes les props dans le composant enfant vont être rafraichies avec les dernières valeurs. Cela signifie qu’il <strong>ne</strong> faut <strong>pas</strong> essayer de changer une prop à l’intérieur d’un composant enfant. Si vous le faites, Vue vous avertira dans la console.</p>
<p>Il y a habituellement deux cas où il est tentant de changer une prop :</p>
<ol>
<li><p>La prop est utilisée uniquement pour passer une valeur d’initialisation. Le composant enfant veut simplement l’utiliser par la suite comme une propriété de donnée locale à partir de ce moment.</p>
</li>
<li><p>La prop est passée comme une valeur brute qui doit être transformée.</p>
</li>
</ol>
<p>Les réponses correctes pour ces cas d’utilisation sont :</p>
<ol>
<li><p>Définir une propriété de donnée locale qui utilise la valeur initiale de la prop comme une valeur d’initialisation :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="keyword">this</span>.initialCounter &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Définir une propriété calculée qui est calculée à partir de la valeur de la prop :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p class="tip">Notez que les objets et tableaux en JavaScript sont passés par référence, aussi si la prop est un tableau ou un objet, modifier l’objet ou le tableau lui-même à l’intérieur de l’enfant <strong>va</strong> affecter l’état du parent.</p>

<h3 id="Validation-de-prop"><a href="#Validation-de-prop" class="headerlink" title="Validation de prop"></a>Validation de prop</h3><p>Il est possible pour un composant de spécifier les conditions à remplir pour les props qu’il reçoit. Si une condition n’est pas satisfaite, Vue émettra des alertes. C’est particulièrement utile quand vous créez un composant qui a pour vocation d’être utilisé par d’autres.</p>
<p>Au lieu de définir les props en tant que tableau de chaine de caractères, vous pouvez utiliser un objet avec des conditions de validation :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// vérification basique du type (`null` signifie l'acceptation de n'importe quel type)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// plusieurs types possibles</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// une chaine de caractères est obligatoire</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// un nombre avec une valeur par défaut</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// les objets et tableaux par défaut doivent être retournés</span></span><br><span class="line">    <span class="comment">// par une fabrique de fonctions</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// fonction de validation personnalisée</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Le <code>type</code> peut être l’un des constructeurs natifs suivants :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>De plus, <code>type</code> peut également être une fonction constructeur personnalisée et ainsi l’assertion sera faite avec une vérification <code>instanceof</code>.</p>
<p>Quand une validation de prop échoue, Vue produira un avertissement dans la console (si vous utilisez le <em>build</em> de développement). Notez que cette props est validée <strong>avant</strong> que l’instance du composant soit créée, donc à l’intérieur des fonctions <code>default</code> ou <code>validator</code>, les propriétés d’instance comme  <code>data</code>, <code>computed</code>, ou <code>methods</code> ne seront pas disponibles.</p>
<h2 id="Attribut-non-prop"><a href="#Attribut-non-prop" class="headerlink" title="Attribut non-prop"></a>Attribut non-prop</h2><p>Un attribut non-prop est un attribut qui est passé au composant, mais qui n’a pas de prop correspondante définie.</p>
<p>Bien que définir explicitement les props soit conseillé pour passer les informations à un composant enfant, les auteurs des bibliothèques de composant ne suivent pas forcément cette règle dans leurs composants. C’est pour cela que les composants peuvent accepter des attributs arbitraires, qui sont ajoutés à l’élément racine du composant.</p>
<p>Par exemple, imaginez que nous utilisions un composant tiers <code>bs-date-input</code> avec un plugin Bootstrap qui nécessite un attribut <code>data-3d-date-picker</code> sur l’<code>input</code>. Nous pouvons ajouter cet attribut dans l’instance de notre composant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bs-date-input</span> <span class="attr">data-3d-date-picker</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">bs-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Et l’attribut <code>data-3d-date-picker=&quot;true&quot;</code> sera automatiquement ajouté à l’élément racine de <code>bs-date-input</code>.</p>
<h2 id="Remplacement-et-merge-avec-des-attributs-existants"><a href="#Remplacement-et-merge-avec-des-attributs-existants" class="headerlink" title="Remplacement et merge avec des attributs existants"></a>Remplacement et merge avec des attributs existants</h2><p>Imaginez que ceci est un template pour <code>bs-date-input</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Pour ajouter un thème spécifique à notre plugin date picker, nous allons avoir besoin d’ajouter une classe, comme cela :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blog-post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"post.content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Dans ce cas, deux valeurs différentes pour <code>class</code> sont définies :</p>
<ul>
<li><code>form-control</code>, qui est la classe du composant dans ce template</li>
<li><code>date-picker-theme-dark</code>, qui est la classe passée au composant depuis son parent</li>
</ul>
<p>Pour la plupart des attributs, la valeur fournie au composant va remplacer la valeur mise initialement dans le composant. Donc par exemple, passer <code>type=&quot;large&quot;</code> va remplacer <code>type=&quot;date&quot;</code> et probablement le rendre inutilisable ! Heureusement, les attributs <code>class</code> et <code>style</code> sont plus malins, aussi les deux valeurs sont mergées, fournissant la valeur finale suivante : <code>form-control date-picker-theme-dark</code>.</p>
<h2 id="Evenements-personnalises"><a href="#Evenements-personnalises" class="headerlink" title="Évènements personnalisés"></a>Évènements personnalisés</h2><p>Nous avons appris que le parent peut passer des données à l’enfant en utilisant les props, mais comment allons-nous informer le parent quand quelque chose survient ? C’est là que le système d’évènement personnalisé de Vue entre en jeu.</p>
<h3 id="Utilisation-de-v-on-avec-les-evenements-personnalises"><a href="#Utilisation-de-v-on-avec-les-evenements-personnalises" class="headerlink" title="Utilisation de v-on avec les évènements personnalisés"></a>Utilisation de <code>v-on</code> avec les évènements personnalisés</h3><p>Chaque instance de Vue implémente une <a href="../api/#Instance-Methods-Events">interface d’évènements</a>, cela signifie qu’elle peut :</p>
<ul>
<li>Écouter un évènement en utilisant <code>$on(eventName)</code></li>
<li>Déclencher un évènement en utilisant <code>$emit(eventName, optionalPayload)</code></li>
</ul>
<p class="tip">Notez que le système d’évènement de Vue est différent de celui de l’API navigateur <a href="https://developer.mozilla.org/fr/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget</a>. Bien qu’il fonctionne de manière similaire, <code>$on</code> et <code>$emit</code> <strong>ne</strong> sont <strong>pas</strong> des alias pour <code>addEventListener</code> et <code>dispatchEvent</code>.</p>

<p>De plus, un composant parent peut écouter des évènements émis depuis un composant enfant en utilisant <code>v-on</code> directement sur le template où le composant enfant est utilisé.</p>
<p class="tip">Vous ne pouvez pas utiliser <code>$on</code> pour écouter les évènements émis par les enfants. Vous devez utiliser <code>v-on</code> directement dans le template, comme dans l’exemple ci-dessous.</p>

<p>Voici un exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter-event-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementCounter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#blog-posts-events-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [<span class="comment">/* ... */</span>],</span><br><span class="line">    postFontSize: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Which can be used in the template to control the font size of all blog posts:</p>
<p>Dans cet exemple, il est important de noter que le composant enfant est toujours complètement découplé de ce qui se passe en dehors de celui-ci. Tout ce qu’il fait, c’est rapporter des informations sur sa propre activité, juste au cas où le composant parent écouterait.</p>
<p>Voici comment utiliser des données complémentaires :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message-event-example"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"msg in messages"</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-message</span> <span class="attr">v-on:message</span>=<span class="string">"handleMessage"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-message'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type="text" v-model="message" /&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click="handleSendMessage"&gt;Envoyer&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'message test'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSendMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'message'</span>, &#123; <span class="attr">message</span>: <span class="keyword">this</span>.message &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">Vue.component('blog-post', &#123;</span></span><br><span class="line"><span class="string">  props: ['post'],</span></span><br><span class="line"><span class="string">  template: `</span></span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"blog-post"</span>&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button&gt;</span></span><br><span class="line"><span class="regexp">        Enlarge text</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">      &lt;div v-html=<span class="string">"post.content"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  `</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>

<div id="message-event-example" class="demo">
  <p v-for="msg in messages">{{ msg }}</p>
  <button-message v-on:message="handleMessage"></button-message>
</div>
<script>
Vue.component('button-message', {
  template: `<div>
    <input type="text" v-model="message" />
    <button v-on:click="handleSendMessage">Envoyer</button>
  </div>`,
  data: function () {
    return {
      message: 'message test'
    }
  },
  methods: {
    handleSendMessage: function () {
      this.$emit('message', { message: this.message })
    }
  }
})
new Vue({
  el: '#message-event-example',
  data: {
    messages: []
  },
  methods: {
    handleMessage: function (payload) {
      this.messages.push(payload.message)
    }
  }
})
</script>

<p>Dans le second exemple, il est important de noter que le composant enfant est toujours complètement découplé de ce qu’il peut se passer à l’extérieur. Tout ce qu’il fait c’est reporter l’information à propos de sa propre activité en incluant les données utiles dans le déclencheur d’évènement, au cas où le composant parant en aurait besoin.</p>
<h3 id="Lier-des-evenements-natifs-aux-composants"><a href="#Lier-des-evenements-natifs-aux-composants" class="headerlink" title="Lier des évènements natifs aux composants"></a>Lier des évènements natifs aux composants</h3><p>Il y a des fois où vous souhaitez écouter un évènement natif sur l’élément racine d’un composant. Dans ce cas, vous devez utiliser le modificateur <code>.native</code> sur <code>v-on</code>. Par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">"doTheThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Modificateur-sync"><a href="#Modificateur-sync" class="headerlink" title="Modificateur .sync"></a>Modificateur <code>.sync</code></h3><blockquote>
<p>2.3.0+</p>
</blockquote>
<p>Dans certains cas, nous pourrions avoir besoin d’une « liaison bidirectionnelle » pour une prop. En fait, dans Vue 1.x, c’est exactement ce que le modificateur <code>.sync</code> permettait. Quand un composant enfant mute une prop qui a <code>.sync</code>, la valeur est remontée au parent. C’est pratique, cependant cela peut conduire à des soucis de maintenance sur le long terme car cela brise l’hypothèse du flux de donnée unidirectionnelle : le code qui mute dans des props enfants affecte l’état du parent.</p>
<p>C’est pour cela que nous avions retiré le modificateur <code>.sync</code> dans la version 2.0. Cependant, nous trouvons tout de même qu’il existe des cas où celle-ci est très utile, notamment pour les composants réutilisables. Ce dont nous avions besoin était <strong>de rendre le code d’un enfant qui affecte l’état d’un parent plus cohérent et explicite.</strong></p>
<p>Dans la 2.3.0+ nous réintroduisons donc le modificateur <code>.sync</code> pour les props, mais cette fois, ce n’est qu’un sucre syntaxique pour étendre automatiquement un écouteur <code>v-on</code> additionnel :</p>
<p>Ce qui suit</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo.sync</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>est le raccourci de :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo</span>=<span class="string">"bar"</span> @<span class="attr">update:foo</span>=<span class="string">"val =&gt; bar = val"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Pour un composant enfant qui met à jour la valeur de <code>foo</code>, il faut explicitement émettre un évènement au lieu de muter la prop :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:foo'</span>, newValue)</span><br></pre></td></tr></table></figure>
<p>Le modificateur <code>.sync</code> peut aussi être utilisé avec <code>v-bind</code> quand il utilise un objet pour affecter plusieurs propriétés en une seule fois :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize += 0.1"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Cela a pour effet d’ajouter des écouteurs de mise à jour <code>v-on</code> sur <code>foo</code> et <code>bar</code>.</p>
<h3 id="Composants-de-champ-de-formulaire-utilisant-les-evenements-personnalises"><a href="#Composants-de-champ-de-formulaire-utilisant-les-evenements-personnalises" class="headerlink" title="Composants de champ de formulaire utilisant les évènements personnalisés"></a>Composants de champ de formulaire utilisant les évènements personnalisés</h3><p>Les évènements personnalisés peuvent aussi être utilisés pour créer des champs personnalisés qui fonctionnent avec <code>v-model</code>. Rappelez-vous :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"something"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>est juste du sucre syntaxique pour :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"something"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"something = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Quand il est utilisé avec un composant, cela peut être simplifié par :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">"something"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"value =&gt; &#123; something = value &#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Donc pour qu’un composant fonctionne avec <code>v-model</code>, il doit :</p>
<ul>
<li>accepter une <code>value</code> prop</li>
<li>émettre un évènement <code>input</code> avec la nouvelle valeur.</li>
</ul>
<p>Voyons cela par l’exemple avec une simple saisie de devise :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">v-model</span>=<span class="string">"price"</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'currency-input'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;span&gt;\</span></span><br><span class="line"><span class="string">      $\</span></span><br><span class="line"><span class="string">      &lt;input\</span></span><br><span class="line"><span class="string">        ref="input"\</span></span><br><span class="line"><span class="string">        v-bind:value="value"\</span></span><br><span class="line"><span class="string">        v-on:input="updateValue($event.target.value)"&gt;\</span></span><br><span class="line"><span class="string">    &lt;/span&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// Au lieu de mettre à jour directement la valeur, cette</span></span><br><span class="line">    <span class="comment">// méthode est utilisée pour formater et mettre des</span></span><br><span class="line">    <span class="comment">// contraintes sur la valeur en entrée</span></span><br><span class="line">    updateValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> formattedValue = value</span><br><span class="line">        <span class="comment">// Retirer les espaces de part et d'autre</span></span><br><span class="line">        .trim()</span><br><span class="line">        <span class="comment">// Tronquer à deux chiffres après la virgule</span></span><br><span class="line">        .slice(</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          value.indexOf(<span class="string">'.'</span>) === <span class="number">-1</span></span><br><span class="line">            ? value.length</span><br><span class="line">            : value.indexOf(<span class="string">'.'</span>) + <span class="number">3</span></span><br><span class="line">        )</span><br><span class="line">      <span class="comment">// Si la valeur n'est pas déjà dans le bon format,</span></span><br><span class="line">      <span class="comment">// la réécrire manuellement pour qu'elle le soit</span></span><br><span class="line">      <span class="keyword">if</span> (formattedValue !== value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.input.value = formattedValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Émettre la valeur du nombre à travers l'évènement input</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="built_in">Number</span>(formattedValue))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<div id="blog-posts-events-demo" class="demo">
  <div :style="{ fontSize: postFontSize + 'em' }">
    <blog-post v-for="post in posts" v-bind:key="post.id" v-bind:post="post" v-on:enlarge-text="postFontSize += 0.1"></blog-post>
  </div>
</div>
<script>
Vue.component('blog-post', {
  props: ['post'],
  template: '\
    <div class="blog-post">\
      <h3>{{ post.title }}</h3>\
      <button v-on:click="$emit(\'enlarge-text\')">\
        Enlarge text\
      </button>\
      <div v-html="post.content"></div>\
    </div>\
  '
})
new Vue({
  el: '#blog-posts-events-demo',
  data: {
    posts: [
      { id: 1, title: 'My journey with Vue', content: '...content...' },
      { id: 2, title: 'Blogging with Vue', content: '...content...' },
      { id: 3, title: 'Why Vue is so fun', content: '...content...' }
    ],
    postFontSize: 1
  }
})
</script>

<p>L’implémentation ci-dessus est plutôt naïve cependant. Par exemple, les utilisateurs peuvent toujours saisir plusieurs points et même parfois des lettres (beurk) ! Donc pour ceux qui souhaiteraient voir un exemple non trivial, voici un filtre de devise plus robuste :</p>
<p>It’s sometimes useful to emit a specific value with an event. For example, we may want the <code>&lt;blog-post&gt;</code> component to be in charge of how much to enlarge the text by. In those cases, we can use <code>$emit</code>‘s 2nd parameter to provide this value:</p>
<h3 id="Personnalisation-de-composant-avec-v-model"><a href="#Personnalisation-de-composant-avec-v-model" class="headerlink" title="Personnalisation de composant avec v-model"></a>Personnalisation de composant avec <code>v-model</code></h3><blockquote>
<p>Nouveau dans la 2.2.0+</p>
</blockquote>
<p>Par défaut, <code>v-model</code> sur un composant utilise <code>value</code> en tant que prop et <code>input</code> en tant qu’évènement, mais plusieurs types de champ comme les cases à cocher et les boutons radio pourraient utiliser <code>value</code> pour un usage différent. Utiliser l’option <code>model</code> permet d’éviter les conflits dans ce genre de situations :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="comment">// ceci permet d'utiliser la prop `value` pour un usage différent</span></span><br><span class="line">    value: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span> <span class="attr">v-model</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"une valeur"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>La partie ci-dessus sera équivalente à :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:checked</span>=<span class="string">"foo"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">change</span>=<span class="string">"val =&gt; &#123; foo = val &#125;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">"une valeur"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p class="tip">Notez que vous devez encore déclarer la prop <code>checked</code> explicitement.</p>

<h3 id="Communication-non-parent-enfant"><a href="#Communication-non-parent-enfant" class="headerlink" title="Communication non parent-enfant"></a>Communication non parent-enfant</h3><p>Parfois deux composants peuvent avoir besoin de communiquer entre eux mais ne sont pas parent et enfant l’un de l’autre. Dans les scénarios simples, vous pouvez utiliser une instance de Vue vide comme canal d’évènements central.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dans la méthode du composant A</span></span><br><span class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dans le hook de création de B</span></span><br><span class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Dans des cas plus complexes, vous pouvez envisager l’utilisation d’un <a href="state-management.html"><em>pattern</em> de management d’état</a>.</p>
<h2 id="Distribution-de-contenu-avec-des-slots"><a href="#Distribution-de-contenu-avec-des-slots" class="headerlink" title="Distribution de contenu avec des slots"></a>Distribution de contenu avec des slots</h2><p>Quand on utilise des composants, il est souvent souhaitable de les composer comme ceci :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">app-footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Il y a deux choses à noter ici :</p>
<ol>
<li><p>Le composant <code>&lt;app&gt;</code> ne sait pas quel contenu il va recevoir. Ceci est défini par le composant qui utilise <code>&lt;app&gt;</code>.</p>
</li>
<li><p>Le composant <code>&lt;app&gt;</code> a vraisemblablement son propre template.</p>
</li>
</ol>
<p>Pour faire fonctionner la composition, nous avons besoin d’un moyen pour entremêler le « contenu » du parent et le template de son propre composant. C’est un processus appelé <strong>distribution de contenu</strong> (ou « transclusion » si vous êtes familier avec Angular). Vue.js implémente une API de distribution de contenu modélisée à partir du <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">brouillon de spécification sur les Web Components</a>, en utilisant l’élément spécial <code>&lt;slot&gt;</code> pour servir de points de distribution pour le contenu original.</p>
<h3 id="Portee-de-compilation"><a href="#Portee-de-compilation" class="headerlink" title="Portée de compilation"></a>Portée de compilation</h3><p>Avant de rentrer plus profondément dans l’API, clarifions dans quelle portée le contenu va être compilé. Imaginez un template comme celui-ci :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>message</code> devrait-il être lié aux données du parent ou aux données de l’enfant ? La réponse est : au parent. Une règle simple pour la portée du composant est :</p>
<blockquote>
<p>Tout ce qui se trouve dans le template parent est compilé dans la portée du parent ; tout ce qui se trouve dans le template enfant est compilé dans la portée de l’enfant.</p>
</blockquote>
<p>Une erreur répandue est d’essayer de lier une directive à une propriété/méthode enfant dans le template du parent :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- NE fonctionne PAS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-show</span>=<span class="string">"someChildProperty"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>En admettant que <code>someChildProperty</code> est une propriété du composant enfant, l’exemple ci-dessus ne fonctionnerait pas. Le template parent n’est pas au courant de l’état du composant enfant.</p>
<p>Si vous avez besoin de lier des directives enfants sur un composant du nœud racine, vous devriez faire cela sur le template du composant enfant :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// ceci fonctionne, car nous sommes dans la bonne portée</span></span><br><span class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Enfant&lt;/div&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      someChildProperty: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>De façon similaire, le contenu distribué sera compilé dans la portée parente.</p>
<h3 id="Slot-unique"><a href="#Slot-unique" class="headerlink" title="Slot unique"></a>Slot unique</h3><p>Le contenu parent sera <strong>évincé</strong> si le template du composant enfant contient au moins une balise <code>&lt;slot&gt;</code>. Quand il n’y a qu’un seul slot sans attribut, tout le fragment de contenu sera inséré à sa position dans le DOM, remplaçant le slot lui-même.</p>
<p>Tout ce qui était contenu à la base dans les balises <code>&lt;slot&gt;</code> est considéré comme <strong>du contenu par défaut</strong>. Le contenu par défaut est compilé dans la portée enfant et ne sera affiché que si l’élément l’incluant est vide et qu’il n’y a pas de contenu à insérer.</p>
<p>Supposons que nous ayons un composant appelé <code>my-component</code> avec le template suivant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Je suis le titre de l'enfant<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">    Ceci ne sera affiché que s'il n'y a pas de contenu</span><br><span class="line">    à distribuer.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Et un parent qui utilise le composant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Je suis le titre du parent<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est le contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est encore du contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Le résultat du rendu sera :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Je suis le titre du parent<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Je suis le titre de l'enfant<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est le contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est encore du contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Slots-nommes"><a href="#Slots-nommes" class="headerlink" title="Slots nommés"></a>Slots nommés</h3><p>Les éléments <code>&lt;slot&gt;</code> ont un attribut spécial, <code>name</code>, qui peut être utilisé pour personnaliser la façon dont le contenu doit être distribué. Vous pouvez avoir de multiples slots avec des noms différents. Un slot nommé ira avec n’importe quel élément possédant l’attribut <code>slot</code> correspondant dans le fragment de contenu.</p>
<p>Il peut encore y avoir un slot non nommé, c’est le <strong>slot par défaut</strong>  qui va servir de fourretout pour tout le contenu ne concordant avec aucun nom. S’il n’y a pas de slot par défaut, le contenu ne concordant pas est évincé.</p>
<p>Par exemple, avec un composant <code>app-layout</code> avec le template suivant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Le balisage du parent :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>Voici un titre de page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Un paragraphe pour le contenu principal.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Et un autre.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>Ici plusieurs informations de contact<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Le résultat du rendu sera :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Voici un titre de page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Un paragraphe pour le contenu principal.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Et un autre.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ici plusieurs informations de contact<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>L’API de distribution de contenu est un mécanisme vraiment utile lors de la conception de composants qui sont censés être composés ensemble.</p>
<h3 id="Slots-avec-portee"><a href="#Slots-avec-portee" class="headerlink" title="Slots avec portée"></a>Slots avec portée</h3><blockquote>
<p>Nouveau dans la 2.1.0+</p>
</blockquote>
<p>Un slot avec portée est un type de slot spécial qui fonctionne comme un template réutilisable (auquel on peut passer des données) au lieu d’éléments déjà rendus.</p>
<p>Dans un composant enfant, passez simplement les données via le slot de la même manière que vous passeriez des props dans un composant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">text</span>=<span class="string">"bonjour de l'enfant"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Dans le parent, un élément <code>&lt;template&gt;</code> avec un attribut spécial <code>slot-scope</code> indique que c’est un template pour un slot avec portée. La valeur de <code>slot-scope</code> est le nom de la variable temporaire qui contient l’objet des props passé à l’enfant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>bonjour du parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Si nous faisons le rendu de ce qui précède, la sortie sera :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bonjour du parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bonjour de l'enfant<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Dans la 2.5.0+, <code>slot-scope</code> n’est plus limité à <code>&lt;template&gt;</code> et peut-être utilisé avec n’importe quel élément ou composant.</p>
</blockquote>
<p>Un cas d’utilisation plus typique des slots avec portée serait un composant de liste qui permettrait à l’utilisateur du composant de personnaliser la manière de faire le rendu de chaque élément de la liste :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-awesome-list</span> <span class="attr">:items</span>=<span class="string">"items"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- le slot avec portée peut également être nommé --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot-scope</span>=<span class="string">"props"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"my-fancy-item"</span>&gt;</span></span><br><span class="line">    &#123;&#123; props.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-awesome-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Et le template pour le composant de liste :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"item in items"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:text</span>=<span class="string">"item.text"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contenu par défaut ici --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Destructuration"><a href="#Destructuration" class="headerlink" title="Destructuration"></a>Destructuration</h4><p>La valeur de <code>slot-scope</code> est en fait une expression JavaScript valide qui apparait à la position d’un argument dans la déclaration d’une fonction. Cela signifie que sur les environnements supportés (dans les composants monofichiers ou dans les navigateurs modernes) vous pouvez aussi utiliser la destructuration ES2015 dans une expression :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; text &#125;"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Composants-dynamiques"><a href="#Composants-dynamiques" class="headerlink" title="Composants dynamiques"></a>Composants dynamiques</h2><p>Vous pouvez utiliser le même point de montage et dynamiquement permuter entre de multiples composants en utilisant l’élément réservé <code>&lt;component&gt;</code> et en les liant dynamiquement à son attribut <code>is</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: <span class="string">'home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    posts: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    archive: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- les composants changent quand vm.currentView change ! --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Si vous préférez, vous pouvez aussi les lier directement à des composants objet :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Home = &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;Bienvenue chez toi !&lt;/p&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endraw %&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Fortunately, this task is made very simple by Vue's custom `&lt;slot&gt;` element:</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">### `keep-alive`</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Si vous voulez garder en mémoire les composants à enlever et ainsi préserver son état ou éviter d'en faire le rendu à nouveau, vous pouvez encapsuler un composant dynamique dans un élément `&lt;keep-alive&gt;` :</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">``` html</span></span><br><span class="line"><span class="regexp">&lt;keep-alive&gt;</span></span><br><span class="line"><span class="regexp">  &lt;component :is="currentView"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;!-- les composants inactifs vont être mis en cache ! --&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>component&gt;</span><br><span class="line">&lt;<span class="regexp">/keep-alive&gt;</span></span><br></pre></td></tr></table></figure>
<p>Obtenez plus de détails sur <code>&lt;keep-alive&gt;</code> dans la <a href="../api/#keep-alive">référence de l’API</a>.</p>
<h2 id="Divers"><a href="#Divers" class="headerlink" title="Divers"></a>Divers</h2><h3 id="Creation-de-composants-reutilisables"><a href="#Creation-de-composants-reutilisables" class="headerlink" title="Création de composants réutilisables"></a>Création de composants réutilisables</h3><p>Lors de la création de composants, il est bon de garder à l’esprit que vous avez l’intention plus tard de les réutiliser ailleurs. Il est acceptable que les composants utilisés qu’une seule fois soient fortement couplés, mais des composants réutilisables doivent définir une interface publique claire et n’émettre aucune hypothèse sur le contexte dans lequel ils sont utilisés.</p>
<p>L’API pour les composants de Vue se découpe en trois parties : les props, les évènements et les slots :</p>
<ul>
<li><p>Les <strong>props</strong> permettent à l’environnement extérieur de passer des données dans le composant</p>
</li>
<li><p>Les <strong>évènements</strong> permettent au composant de déclencher des effets de bord dans l’environnement extérieur</p>
</li>
<li><p>Les <strong>slots</strong> permettent à l’environnement extérieur de composer le composant avec du contenu additionnel.</p>
</li>
</ul>
<p>les syntaxes abrégées dédiées à <code>v-bind</code> et <code>v-on</code>, l’intention peut être clairement et succinctement communiquée dans le template :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:foo</span>=<span class="string">"baz"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:bar</span>=<span class="string">"qux"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">event-a</span>=<span class="string">"doThis"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">event-b</span>=<span class="string">"doThat"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"main-text"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Les-refs-des-composants-enfants"><a href="#Les-refs-des-composants-enfants" class="headerlink" title="Les refs des composants enfants"></a>Les refs des composants enfants</h3><p>Malgré l’existence des props et des évènements, parfois vous aurez toujours besoin d’accéder directement à un composant enfant en JavaScript. Pour parvenir à cela vous pouvez assigner un ID de référence au composant enfant en utilisant <code>ref</code>. Par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user-profile</span> <span class="attr">ref</span>=<span class="string">"profile"</span>&gt;</span><span class="tag">&lt;/<span class="name">user-profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#parent'</span> &#125;)</span><br><span class="line"><span class="comment">// accès au composant enfant</span></span><br><span class="line"><span class="keyword">var</span> child = parent.$refs.profile</span><br></pre></td></tr></table></figure>
<p>Quand <code>ref</code> est utilisé conjointement avec <code>v-for</code>, la référence que vous obtenez sera un tableau ou un objet contenant les composants enfants reflétant la source de donnée.</p>
<p class="tip">Les <code>$refs</code> sont seulement renseignées après le rendu du composant, et ne sont pas réactives. Elles sont seulement destinées à servir de porte dérobée pour la manipulation directe d’enfant (vous devriez éviter d’utiliser <code>$refs</code> dans vos templates et propriétés calculées).</p>

<h3 id="Composants-asynchrones"><a href="#Composants-asynchrones" class="headerlink" title="Composants asynchrones"></a>Composants asynchrones</h3><p>Dans de grosses applications, nous avons parfois besoin de diviser la structure en de plus petits fragments et uniquement charger le composant depuis le serveur quand c’est vraiment nécessaire. Pour rendre ça plus simple, Vue permet de définir votre composant comme une fabrique de fonctions qui résoudra de manière asynchrone la définition de votre composant. Vue déclenchera la fabrique de fonctions uniquement lorsque le rendu du composant est vraiment nécessaire sur le composant et mettra ce rendu en cache pour le resservir lors de futures demandes de rendu. Par exemple :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Passer la définition du composant à la fonction de rappel `resolve`</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>La fabrique de fonctions reçoit une fonction de rappel <code>resolve</code> qui devra être appelée quand vous aurez récupéré la définition de votre composant depuis le serveur. Vous pouvez également appeler <code>reject(reason)</code> pour indiquer que le chargement a échoué. La fonction <code>setTimeout</code> est simplement là en tant qu’exemple ; la manière de récupérer le composant est entièrement à votre charge. Une approche recommandée est d’utiliser les composants asynchrones conjointement avec <a href="https://webpack.js.org/guides/code-splitting-require/" target="_blank" rel="noopener">la fonctionnalité de scission de code de webpack</a> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Cette syntaxe de `require` va indiquer à webpack</span></span><br><span class="line">  <span class="comment">// de découper automatiquement votre code après build dans</span></span><br><span class="line">  <span class="comment">// des paquetages (« bundles ») qui seront chargés par des requêtes Ajax.</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Vous pouvez également retourner une <code>Promise</code> (promesse) dans la fabrique de fonctions ainsi avec webpack 2 et la syntaxe ES2015 vous pouvez faire :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// La fonction `import` retourne un objet `Promise`.</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Quand vous utilisez une <a href="components.html#Local-Registration">inscription locale</a>, vous pouvez également fournir une fonction qui retourne une <code>Promise</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#dynamic-component-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentTab: <span class="string">'Home'</span>,</span><br><span class="line">    tabs: [<span class="string">'Home'</span>, <span class="string">'Posts'</span>, <span class="string">'Archive'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    currentTabComponent: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'tab-'</span> + <span class="keyword">this</span>.currentTab.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p class="tip">Si vous êtes un utilisateur de <strong>Browserify</strong> et que vous souhaitez utiliser les composants asynchrones, son créateur a malheureusement <a href="https://github.com/substack/node-browserify/issues/58#issuecomment-21978224" target="_blank" rel="noopener">été clair</a> sur le fait que le chargement asynchrone « n’est pas quelque chose que Browserify supportera un jour ». Officiellement, du moins. La communauté Browserify a trouvé <a href="https://github.com/vuejs/vuejs.org/issues/620" target="_blank" rel="noopener">plusieurs solutions de contournement</a>, qui peuvent être utiles pour des applications complexes déjà existantes. Pour tous les autres scénarios, nous vous recommandons simplement d’utiliser webpack pour un support de première classe des composants asynchrones, intégré par défaut.</p>

<h3 id="Composants-asynchrones-avances"><a href="#Composants-asynchrones-avances" class="headerlink" title="Composants asynchrones avancés"></a>Composants asynchrones avancés</h3><blockquote>
<p>Nouveau dans la 2.3.0+</p>
</blockquote>
<p>Introduit dans la 2.3.0+, le générateur de composant asynchrone peut aussi retourner un objet au format suivant :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// Le composant à charger. Il peut être une Promesse (« Promise »)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComp.vue'</span>),</span><br><span class="line">  <span class="comment">// Un composant à utiliser pendant que le composant asynchrone se charge</span></span><br><span class="line">  loading: LoadingComp,</span><br><span class="line">  <span class="comment">// Un composant à utiliser en cas d'échec de chargement du composant</span></span><br><span class="line">  error: ErrorComp,</span><br><span class="line">  <span class="comment">// Délai avant de montrer le composant de chargement (loading). Par défaut à : 200ms.</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// Le composant d'erreur est affiché si la limite d'attente</span></span><br><span class="line">  <span class="comment">// fixée est dépassée. Par défaut à : Infinity.</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Notez qu’en utilisant cela en tant que composant de <code>vue-router</code>, ces propriétés vont être ignorées car les composants asynchrones sont résolus avant que la navigation n’intervienne. Vous pouvez utiliser <code>vue-router</code> 2.4.0+ si vous souhaitez utiliser la syntaxe ci-dessus pour des composants de route.</p>
<h3 id="Conventions-de-nommage-d’un-composant"><a href="#Conventions-de-nommage-d’un-composant" class="headerlink" title="Conventions de nommage d’un composant"></a>Conventions de nommage d’un composant</h3><p>Quand vous inscrivez un composant (ou des props), vous pouvez utiliser la kebab-case, la camelCase ou la PascalCase.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dans une définition de composant</span></span><br><span class="line">components: &#123;</span><br><span class="line">  <span class="comment">// inscription utilisant la kebab-case</span></span><br><span class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// inscription utilisant la camelCase</span></span><br><span class="line">  <span class="string">'camelCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// inscription utilisant la PascalCase</span></span><br><span class="line">  <span class="string">'PascalCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>À l’intérieur des templates HTML cependant, vous devez utiliser les équivalences de la kebab-case :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- toujours utiliser la kebab-case dans les templates --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kebab-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">kebab-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">camel-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">camel-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pascal-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">pascal-cased-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Quand vous utilisez des templates basés sur les <em>chaines de caractères</em> cependant, vous n’avez pas les restrictions liées à la sensibilité à la casse du HTML. Cela signifie que même dans le template, vous pouvez référencer vos composants et props en utilisant :</p>
<ul>
<li>la kebab-case</li>
<li>la camelCase ou la kebab-case si le composant a été défini avec la camelCase</li>
<li>la kebab-case, la camelCase ou la PascalCase si le composant a été défini avec la PascalCase</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  camelCasedComponent: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  PascalCasedComponent: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-component-demo-tab-button-active &#123;</span><br><span class="line">  background: #e0e0e0;</span><br><span class="line">&#125;</span><br><span class="line">.dynamic-component-demo-tab &#123;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">  padding: <span class="number">10</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endraw %&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">The above is made possible by Vue's `&lt;component&gt;` element with the `is` special attribute:</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">```html</span></span><br><span class="line"><span class="regexp">&lt;!-- Component changes when currentTabComponent changes --&gt;</span></span><br><span class="line"><span class="regexp">&lt;component v-bind:is="currentTabComponent"&gt;&lt;/</span>component&gt;</span><br></pre></td></tr></table></figure>
<p>Cela signifie que la PascalCase est la <em>convention de déclaration</em> la plus universelle et que la kebab-case est la <em>convention d’utilisation</em> la plus universelle.</p>
<p>Si votre composant ne passe pas de contenu via des éléments <code>slot</code> vous pouvez même utiliser la syntaxe d’autofermeture <code>/</code> après le nom :</p>
<p>See <a href="https://jsfiddle.net/chrisvfritz/o3nycadu/" target="_blank" rel="noopener">this fiddle</a> to experiment with the full code, or <a href="https://jsfiddle.net/chrisvfritz/b2qj69o1/" target="_blank" rel="noopener">this version</a> for an example binding to a component’s options object, instead of its registered name.</p>
<p>Encore une fois, cela fonctionne <em>seulement</em> dans les templates sous forme de chaine de caractères. Les éléments autofermants ne sont pas du HTML valide et l’analyseur HTML natif de votre navigateur ne le comprendra pas.</p>
<h3 id="Composants-recursifs"><a href="#Composants-recursifs" class="headerlink" title="Composants récursifs"></a>Composants récursifs</h3><p>Les composants peuvent s’invoquer récursivement dans leur propre template. Cependant, ils peuvent uniquement le faire avec l’option <code>name</code> :</p>
<p>This will lead to issues when using components with elements that have such restrictions. For example:</p>
<p>Quand vous inscrivez un composant de manière globale en utilisant <code>Vue.component</code>, l’ID global est automatiquement défini en tant qu’option <code>name</code> du composant.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Si vous n’êtes pas prudent, les composants récursifs peuvent conduire à des boucles infinies :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>
<p>Un composant comme celui ci-dessus conduira à une erreur « taille maximale de pile dépassée »  (“max stack size exceeded”), donc assurez-vous que les invocations récursives soient conditionnelles (c.-à-d. utilisent un <code>v-if</code> qui vaudra éventuellement <code>false</code>).</p>
<h3 id="References-circulaires-entre-les-composants"><a href="#References-circulaires-entre-les-composants" class="headerlink" title="Références circulaires entre les composants"></a>Références circulaires entre les composants</h3><p>Imaginons que vous construisiez une arborescence de fichiers, comme Finder ou File Explorer. Vous pouvez avoir un composant <code>tree-folder</code> avec ce template :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Puis un composant <code>tree-folder-contents</code> avec ce template :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"blog-post-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>En regardant attentivement, vous verrez que ces composants seront en fait l’ancêtre <em>et</em> le descendant l’un de l’autre dans l’arbre de rendu — un paradoxe ! Quand vous inscrivez un composant de manière globale avec <code>Vue.component</code>, ce paradoxe est résolu pour vous automatiquement. Si c’est votre cas, vous pouvez arrêter de lire ici.</p>
<p>Cependant, si vous réclamez/importez des composants en utilisant un <strong>système de module</strong>, c.-à-d. via webpack ou Browserify, vous obtiendrez une erreur « Échec de montage du composant : un template ou une fonction de rendu n’est pas défini. » :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to mount component: template or render function not defined</span><br></pre></td></tr></table></figure>
<p>Pour expliquer ce qui arrive, je vais appeler nos composants A et B. Le système de module voit de quoi A a besoin, d’abord A a besoin de B, mais B a besoin de A, mais A a besoin de B, etc., etc. Ça tourne en boucle, ne sachant pas comment complètement résoudre l’un ou l’autre des composants sans en résoudre un avant l’autre. Pour régler ça, nous avons besoin de donner au système de module un moyen de dire, « A a <em>éventuellement</em> besoin de B, mais il n’y a pas de raison de résoudre B en premier. ».</p>
<p>Dans notre cas, je ferais cela avec le composant <code>tree-folder</code>. Nous savons que l’enfant crée un paradoxe dans le composant <code>tree-folder-contents</code>, nous allons donc attendre le hook <code>beforeCreate</code> du cycle de vie pour l’inscrire :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Problème résolu !</p>
<h3 id="Templates-avec-inline-template"><a href="#Templates-avec-inline-template" class="headerlink" title="Templates avec inline-template"></a>Templates avec <code>inline-template</code></h3><p>Quand l’attribut spécifique <code>inline-template</code> est présent sur le composant enfant, il va utiliser son contenu interne en tant que template, plutôt que de le traiter comme un contenu distribué. Cela permet une création de template plus flexible.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est traité comme le template du composant lui-même.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Il n'y aura pas de transclusion de contenu.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Cependant, la propriété <code>inline-template</code> rend la portée de votre template difficile à appréhender. Pour une bonne pratique, optez plutôt pour définir vos templates à l’intérieur du composant en utilisant l’option <code>template</code> ou un élément <code>template</code> dans un fichier <code>.vue</code>.</p>
<h3 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h3><p>Un autre moyen de définir des templates est de le faire à l’intérieur d’un élément <code>script</code> avec le type <code>text/x-template</code>, quand vous référencez le template par son id. Par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-template"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bonjour bonjour bonjour<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#hello-world-template'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Cela peut être pratique pour des démos avec de gros templates ou dans des applications extrêmement petites, mais cela devrait être évité dans tous les autres cas, car cela sépare les templates du reste de la définition du composant.</p>
<h3 id="Composants-statiques-peu-couteux-avec-v-once"><a href="#Composants-statiques-peu-couteux-avec-v-once" class="headerlink" title="Composants statiques peu couteux avec v-once"></a>Composants statiques peu couteux avec <code>v-once</code></h3><p>Faire le rendu d’éléments HTML est vraiment rapide avec Vue, mais parfois vous pouvez avoir un composant qui contient <strong>beaucoup</strong> de contenu statique. Dans ces cas, vous pouvez vous assurer qu’il n’est évalué qu’une seule fois puis mis en cache avec la directive <code>v-once</code> sur l’élément racine, comme cela :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Conditions d'utilisation&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... beaucoup de contenu statique ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

  
  
    <div class="guide-links">
      
      
        <span>← <a href="/v2/guide/forms.html">Liaisons sur les champs de formulaire</a></span>
      
      
      
        <span style="float: right;"><a href="/v2/guide/components-registration.html">Component Registration</a> →</span>
      
    </div>
  
  <div class="footer">
      <script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div class="bsa-cpc"></div>
<script>
  (function(){
    if(typeof _bsa !== 'undefined' && _bsa) {
    _bsa.init('default', 'CKYD62QM', 'placement:vuejsorg', {
      target: '.bsa-cpc',
      align: 'horizontal',
      disable_css: 'true'
    });
      }
  })();
</script>

    Une erreur dans cette page ? Envie de contribuer à la traduction ?
    <a href="https://github.com/vuejs-fr/vuejs.org/blob/master/src/v2/guide/components.md" target="_blank">
      Éditez cette page sur GitHub !
    </a>
  </div>
</div>

        
      </div>
      <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/css.escape.js"></script>
    <script src="/js/common.js"></script>

    <!-- search -->
    <link href="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/search.css">
    <script src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
    <script>
    [
      '#search-query-nav',
      '#search-query-sidebar',
      '#search-query-menu'
    ].forEach(function (selector) {
      if (!document.querySelector(selector)) return
      // search index defaults to v2
      var match = window.location.pathname.match(/^\/(v\d+)/)
      var version = match ? match[1] : 'v2'
      docsearch({
      appId: 'BH4D9OD16A',
      apiKey: '85cc3221c9f23bfbaa4e3913dd7625ea',
      indexName: 'vuejs',
      inputSelector: selector,
      algoliaOptions: { facetFilters: ["version:" + version] }
      })
    })
    </script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
