
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Composants — Vue.js</title>
        <meta charset="utf-8">
        <meta name="description" content="Vue.js - Créer rapidement et intuitivement des interfaces intéractives MVVM organisées.">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

        <meta property="og:type" content="article">
        <meta property="og:title" content="Composants — Vue.js">
        <meta property="og:description" content="Vue.js - Créer rapidement et intuitivement des interfaces intéractives MVVM organisées.">
        <meta property="og:image" content="https://vuejs.org//images/logo.png">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Composants — Vue.js">
        <meta name="twitter:description" content="Vue.js - Créer rapidement et intuitivement des interfaces intéractives MVVM organisées.">
        <meta name="twitter:image" content="https://vuejs.org/images/logo.png">

        <link rel="icon" href="/images/logo.png" type="image/x-icon">

        <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Dosis:500&text=Vue.js' rel='stylesheet' type='text/css'>

        <!-- main page styles -->
        <link rel="stylesheet" href="/css/page.css">

        <!-- this needs to be loaded before guide's inline scripts -->
        <script src="/js/vue.js"></script>
        <script>window.PAGE_TYPE = "guide"</script>

        <!-- ga -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-46852172-1', 'vuejs.org');
          ga('send', 'pageview');
        </script>
    </head>
    <body class="docs">        <div id="mobile-bar" >
            <a class="menu-button"></a>
            <a class="logo" href="/"></a>
        </div>
        <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png">
    <span>Vue.js</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li>
<li><a href="/v2/guide/" class="nav-link current">Guide</a></li>
<li><a href="/v2/api/" class="nav-link">API</a></li>
<li><a href="/v2/examples/" class="nav-link">Exemples</a></li>
<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Écosystème</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Aide</h4></li>
    <li><ul>
      <li style="text-align: left;padding: 0 24px 0 20px"><a style="display: inline-block;padding: 0;" href="http://forum.vuejs.org" class="nav-link" target="_blank">Forum</a> (<a style="display: inline-block;padding: 0;" href="https://forum.vuejs.org/c/french" class="nav-link" target="_blank">Fr</a>)</li>
      <li style="text-align: left;padding: 0 24px 0 20px"><a style="display: inline-block;padding: 0;" href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">Chat</a> (<a style="display: inline-block;padding: 0;" href="https://gitter.im/vuejs-fr/vue" class="nav-link" target="_blank">Fr</a>)</li>
      <li><a href="https://github.com/vuejs-templates" class="nav-link" target="_blank">Templates</a></li>
    </ul></li>
    <li><h4>Infos</h4></li>
    <li><ul>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Blog</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">Offres d'emploi</a></li>
    </ul></li>
    <li><h4>Plugins officiels</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
    </ul></li>
    <li><h4>Liste de ressources</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Dépôt officiel</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue</a></li>
    </ul></li>
  </ul>
</li>



<li class="nav-dropdown-container language">
  <a class="nav-link">Traductions</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://vuejs.org/" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://br.vuejs.org/" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://ru.vuejs.org/" class="nav-link" target="_blank">Русский</a></li>
  </ul>
</li>

<li>
  <a href="https://vue.threadless.com" target="_blank" class="nav-link shop">Boutique</a>
</li>

  </ul>
</div>

        
            <div id="main" class="fix-sidebar">
                
                    
    <div class="sidebar">
    <ul class="main-menu">
        <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li>
<li><a href="/v2/guide/" class="nav-link current">Guide</a></li>
<li><a href="/v2/api/" class="nav-link">API</a></li>
<li><a href="/v2/examples/" class="nav-link">Exemples</a></li>
<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">Écosystème</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>Aide</h4></li>
    <li><ul>
      <li style="text-align: left;padding: 0 24px 0 20px"><a style="display: inline-block;padding: 0;" href="http://forum.vuejs.org" class="nav-link" target="_blank">Forum</a> (<a style="display: inline-block;padding: 0;" href="https://forum.vuejs.org/c/french" class="nav-link" target="_blank">Fr</a>)</li>
      <li style="text-align: left;padding: 0 24px 0 20px"><a style="display: inline-block;padding: 0;" href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">Chat</a> (<a style="display: inline-block;padding: 0;" href="https://gitter.im/vuejs-fr/vue" class="nav-link" target="_blank">Fr</a>)</li>
      <li><a href="https://github.com/vuejs-templates" class="nav-link" target="_blank">Templates</a></li>
    </ul></li>
    <li><h4>Infos</h4></li>
    <li><ul>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">Blog</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">Offres d'emploi</a></li>
    </ul></li>
    <li><h4>Plugins officiels</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
    </ul></li>
    <li><h4>Liste de ressources</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">Dépôt officiel</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Awesome Vue</a></li>
    </ul></li>
  </ul>
</li>



<li class="nav-dropdown-container language">
  <a class="nav-link">Traductions</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://jp.vuejs.org/" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://kr.vuejs.org/" class="nav-link" target="_blank">한국어</a></li>
    <li><a href="https://vuejs.org/" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://br.vuejs.org/" class="nav-link" target="_blank">Português</a></li>
    <li><a href="https://ru.vuejs.org/" class="nav-link" target="_blank">Русский</a></li>
  </ul>
</li>

<li>
  <a href="https://vue.threadless.com" target="_blank" class="nav-link shop">Boutique</a>
</li>

    </ul>
    <div class="list">
        <div class="main-sponsor">
            <span>Sponsor de platine</span><br>
            <a href="https://stdlib.com" target="_blank" class="logo">
                <img src="/images/stdlib.png">
            </a>
        </div>
        <a class="become-backer" href="/support-vuejs">
            Apporter son soutien
        </a>
        <h2>
            Guide
            
                <select class="version-select">
                    <option value="SELF" selected>2.x</option>
                    <option value="v1">1.0</option>
                    <option value="012">0.12</option>
                    <option value="011">0.11</option>
                </select>
            
        </h2>
        <ul class="menu-root">
            
                
                
                    
                      <li><h3>Essentiel</h3></li>
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/installation.html" class="sidebar-link">Installation</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/index.html" class="sidebar-link">Introduction</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/instance.html" class="sidebar-link">L'instance de Vue</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/syntax.html" class="sidebar-link">Syntaxe de template</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/computed.html" class="sidebar-link">Propriétés calculées et observateurs</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/class-and-style.html" class="sidebar-link">Liaisons de classes et de styles</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/conditional.html" class="sidebar-link">Rendu conditionnel</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/list.html" class="sidebar-link">Rendu de liste</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/events.html" class="sidebar-link">Gestion des évènements</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/forms.html" class="sidebar-link">Liaisons sur les champs de formulaire</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/components.html" class="sidebar-link current">Composants</a>
                </li>
            
                
                
                    
                    
                      <li><h3>Avancé</h3></li>
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/reactivity.html" class="sidebar-link">La réactivité dans le détail</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/transitions.html" class="sidebar-link">Transition Effects (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/transitioning-state.html" class="sidebar-link">Transitioning State (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/render-function.html" class="sidebar-link">Render Functions (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/custom-directive.html" class="sidebar-link">Custom Directives (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/mixins.html" class="sidebar-link">Mixins</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/plugins.html" class="sidebar-link">Plugins (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/single-file-components.html" class="sidebar-link">Les composants monofichiers</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/deployment.html" class="sidebar-link">Production Deployment Tips (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/routing.html" class="sidebar-link">Routage</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/state-management.html" class="sidebar-link">State Management (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/unit-testing.html" class="sidebar-link">Unit Testing (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/ssr.html" class="sidebar-link">Rendu côté serveur</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/typescript.html" class="sidebar-link">TypeScript Support (En)</a>
                </li>
            
                
                
                    
                    
                    
                      <li><h3>Migration</h3></li>
                    
                    
                
                
                <li>
                    <a href="/v2/guide/migration.html" class="sidebar-link">Migration from Vue 1.x (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/migration-vue-router.html" class="sidebar-link">Migration from Vue Router 0.7.x (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/migration-vuex.html" class="sidebar-link">Migration from Vuex 0.6.x to 1.0 (En)</a>
                </li>
            
                
                
                    
                    
                    
                    
                      <li><h3>Meta</h3></li>
                    
                
                
                <li>
                    <a href="/v2/guide/comparison.html" class="sidebar-link">Comparaison avec les autres frameworks</a>
                </li>
            
                
                
                    
                    
                    
                    
                
                
                <li>
                    <a href="/v2/guide/join.html" class="sidebar-link">Join the Vue.js Community! (En)</a>
                </li>
            
            
        </ul>
    </div>
</div>


<div class="content guide with-sidebar components-guide">
    
      <div id="ad">
  <!-- <span>Sponsored By</span><br>
  <a href="http://www.thedifferenceengine.io/" target="_blank"
    style="background-color: rgba(0,0,0,.85); padding: 10px 0">
    <img src="/images/tde.png">
  </a> -->
  <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=vuejs" id="_carbonads_js"></script>
</div>

    
    
      <h1>Composants</h1>
    
    <h2 id="Les-composants-qu’est-ce-que-c’est"><a href="#Les-composants-qu’est-ce-que-c’est" class="headerlink" title="Les composants, qu’est-ce que c’est ?"></a>Les composants, qu’est-ce que c’est ?</h2><p>Les composants sont l’une des plus puissantes fonctionnalités de Vue. Ils vous permettent d’étendre les éléments de base du HTML pour encapsuler du code réutilisable. À un haut niveau, les composants sont des éléments personnalisables auxquels le compilateur de Vue attache un comportement. Dans certains cas, ils peuvent aussi apparaître comme des éléments HTML natifs étendus avec l’attribut spécial <code>is</code>.</p>
<h2 id="Utilisation-des-composants"><a href="#Utilisation-des-composants" class="headerlink" title="Utilisation des composants"></a>Utilisation des composants</h2><h3 id="Inscription"><a href="#Inscription" class="headerlink" title="Inscription"></a>Inscription</h3><p>Nous avons appris dans les sections précédentes que nous pouvions créer une nouvelle instance de Vue avec :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#some-element'</span>,</div><div class="line">  <span class="comment">// options</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Pour inscrire un composant global, vous pouvez utiliser <code>Vue.component(tagName, options)</code>. Par exemple :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</div><div class="line">  <span class="comment">// options</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p class="tip">Notez que Vue ne vous force pas à respecter les <a href="http://www.w3.org/TR/custom-elements/#concepts" target="_blank" rel="external">règles du W3C</a> en ce qui concerne les noms de balises personnalisées (tout en minuscules, obligation de contenir un trait d’union) bien que suivre cette convention est considéré comme une bonne pratique.</p>

<p>Une fois inscrit, un composant peut être utilisé dans le template d’une instance en tant qu’élément personnalisé, <code>&lt;my-component&gt;&lt;/my-component&gt;</code>. Assurez-vous que le composant soit inscrit <strong>avant</strong> l’instanciation de l’instance racine de Vue. Voici un exemple complet :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// inscrire</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;Un composant personnalisé !&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// créer une instance racine</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#example'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Ce qui donnera comme rendu :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Un composant personnalisé !<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>

<div id="example" class="demo">
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<div>Un composant personnalisé !</div>'
})
new Vue({ el: '#example' })
</script>

<h3 id="Inscription-locale"><a href="#Inscription-locale" class="headerlink" title="Inscription locale"></a>Inscription locale</h3><p>Vous n’êtes pas obligé d’inscrire chaque composant de manière globale. Vous pouvez rendre un composant disponible dans la portée d’un(e) autre composant/instance en l’inscrivant avec l’option <code>components</code> lors de l’instanciation :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Child = &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;Un composant personnalisé !&lt;/div&gt;'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  components: &#123;</div><div class="line">    <span class="comment">// &lt;my-component&gt; ne sera disponible que dans le template parent</span></div><div class="line">    <span class="string">'my-component'</span>: Child</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>La même encapsulation s’applique pour les autres fonctionnalités de Vue pouvant être inscrites, comme les directives.</p>
<h3 id="Limitations-de-l’analyse-d’un-template-a-partir-du-DOM"><a href="#Limitations-de-l’analyse-d’un-template-a-partir-du-DOM" class="headerlink" title="Limitations de l’analyse d’un template à partir du DOM"></a>Limitations de l’analyse d’un template à partir du DOM</h3><p>Quand vous utilisez le DOM en tant que template (ex. : en utilisant l’option <code>el</code> pour monter un élément avec du contenu existant), vous êtes sujet à plusieurs restrictions dépendantes de la façon dont fonctionne le HTML, car Vue peut uniquement récupérer le contenu du template <strong>après</strong> qu’il ait été analysé et normalisé. Des éléments tels que <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> et <code>&lt;select&gt;</code> ont notamment des restrictions sur les éléments que l’on peut trouver à l’intérieur, et plusieurs éléments comme <code>&lt;option&gt;</code> ne peuvent apparaître qu’à l’intérieur de certains éléments.</p>
<p>Ceci est problématique quand on utilise des composants personnalisés avec des éléments qui ont ces restrictions, par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-row</span>&gt;</span>...<span class="tag">&lt;/<span class="name">my-row</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Le composant personnalisé <code>&lt;my-row&gt;</code> sera évalué comme du contenu invalide, ce qui causera des erreurs dans les éventuels rendus en sortie. Une solution de contournement est d’utiliser l’attribut spécial <code>is</code> :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>Il est à noter que ces limitations n’existent pas si vous utilisez des templates sous forme de chaîne de caractères en provenance d’une des sources suivantes</strong> :</p>
<ul>
<li>les balises <code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
<li>les templates de chaîne de caractères littérales en JavaScript</li>
<li>les composants <code>.vue</code></li>
</ul>
<p>Donc, préférez l’utilisation des templates de chaîne de caractères lorsque c’est possible.</p>
<h3 id="data-doit-etre-une-fonction"><a href="#data-doit-etre-une-fonction" class="headerlink" title="data doit être une fonction"></a><code>data</code> doit être une fonction</h3><p>La plupart des options qui peuvent être passées dans le constructeur de Vue peuvent être utilisées dans un composant, avec un cas particulier : <code>data</code> doit être une fonction. En fait, si vous essayez ça :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">message</span>: <span class="string">'bonjour'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Alors Vue s’arrêtera et lancera des avertissements dans la console, vous indiquant que <code>data</code> doit être une fonction pour les instances de composant. Cependant, il serait bien de comprendre pourquoi cette règle existe, alors trichons.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</div><div class="line"></div><div class="line">Vue.component(<span class="string">'simple-counter'</span>, &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;button v-on:click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class="line">  <span class="comment">// data est techniquement une fonction, donc Vue ne va</span></div><div class="line">  <span class="comment">// pas se plaindre, mais nous allons retourner la même</span></div><div class="line">  <span class="comment">// réference d'objet pour chaque instance de composant</span></div><div class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> data</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#example-2'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>

<div id="example-2" class="demo">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
<script>
var data = { counter: 0 }
Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return data
  }
})
new Vue({
  el: '#example-2'
})
</script>

<p>Puisque nos trois instances de composant partagent le même objet <code>data</code>, l’incrémentation d’un compteur les incrémentera tous ! Aie. Corrigeons cela en retournant un nouvel objet de données :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">counter</span>: <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Maintenant tous nos compteurs ont leur propre état interne :</p>

<div id="example-2-5" class="demo">
  <my-component></my-component>
  <my-component></my-component>
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  }
})
new Vue({
  el: '#example-2-5'
})
</script>

<h3 id="Composition-de-composants"><a href="#Composition-de-composants" class="headerlink" title="Composition de composants"></a>Composition de composants</h3><p>Les composants sont destinés à être utilisés ensemble, le plus souvent dans une relation parent-enfant : le composant A peut utiliser le composant B dans son propre template. Ils vont inévitablement avoir besoin de communiquer les uns avec les autres : le parent peut avoir besoin de passer des données à l’enfant, et l’enfant peut avoir besoin d’informer le parent que quelque chose s’est produit à l’intérieur. Cependant, il est également très important de garder le parent et l’enfant aussi découplés que possible via une interface clairement définie. Cela assure que le code de chaque composant peut être écrit de manière relativement isolée, cela les rend plus maintenables et potentiellement plus simples à ré-utiliser.</p>
<p>Dans Vue.js, la relation parent-enfant peut être résumée ainsi : <strong>descente de props, remontée d’événements</strong>. Le parent passe les données à l’enfant via les <strong>props</strong>, et l’enfant envoie des messages à son parent via les <strong>événements</strong>. Voyons comment cela fonctionne ci-dessous.</p>
<p style="text-align: center"><br>  <img style="width:300px" src="/images/props-events.png" alt="props down, events up"><br></p>

<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><h3 id="Passer-des-donnees-avec-props"><a href="#Passer-des-donnees-avec-props" class="headerlink" title="Passer des données avec props"></a>Passer des données avec props</h3><p>Chaque instance de composant a sa propre <strong>portée isolée</strong>. Cela signifie qu’on ne peut (et ne devrait) pas directement référencer des données du parent dans un template de composant enfant. Les données doivent être passées aux composants enfants en utilisant <strong>props</strong>.</p>
<p>Une prop est un attribut personnalisé permettant de passer des informations depuis des composants parents. Un composant enfant a besoin de déclarer explicitement quelles sont les props qu’il s’attend à recevoir en utilisant <a href="../api/#props">l’option <code>props</code></a> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'child'</span>, &#123;</div><div class="line">  <span class="comment">// déclarer les props</span></div><div class="line">  props: [<span class="string">'message'</span>],</div><div class="line">  <span class="comment">// tout comme les data, une prop peut être utilisée à l'intérieur de templates</span></div><div class="line">  <span class="comment">// et est également disponible dans la vm via this.message</span></div><div class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Alors nous pouvons lui passer une simple chaîne de caractères comme suit :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">"bonjour !"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Résultat :</p>

<div id="prop-example-1" class="demo">
  <child message="bonjour !"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['message'],
      template: '<span>{{ message }}</span>'
    }
  }
})
</script>

<h3 id="camelCase-vs-kebab-case"><a href="#camelCase-vs-kebab-case" class="headerlink" title="camelCase vs. kebab-case"></a>camelCase vs. kebab-case</h3><p>Les attributs HTML sont insensibles à la casse, donc quand vous utilisez des templates qui ne sont pas des chaînes de caractères, le nom de la prop en camelCase a besoin de son équivalent en kebab-case (délimité par des traits d’union) :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'child'</span>, &#123;</div><div class="line">  <span class="comment">// camelCase en JavaScript</span></div><div class="line">  props: [<span class="string">'myMessage'</span>],</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- kebab-case en HTML --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">my-message</span>=<span class="string">"bonjour !"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Encore une fois, si vous utilisez les templates sous forme de chaîne de caractères, ces limitations ne s’appliquent pas.</p>
<h3 id="Props-dynamiques"><a href="#Props-dynamiques" class="headerlink" title="Props dynamiques"></a>Props dynamiques</h3><p>Tout comme la liaison d’un attribut ordinaire avec une expression, nous pouvons aussi utiliser <code>v-bind</code> pour dynamiquement lier les props aux données de leurs parents. À chaque fois que les données sont mises à jour dans le parent, elles seront également mises à jour dans l’enfant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"parentMsg"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>C’est souvent plus simple d’utiliser la syntaxe abrégée pour <code>v-bind</code> :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Résultat :</p>

<div id="demo-2" class="demo">
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Message venant du parent'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{myMessage}}</span>'
    }
  }
})
</script>

<h3 id="Litterale-vs-Dynamique"><a href="#Litterale-vs-Dynamique" class="headerlink" title="Littérale vs. Dynamique"></a>Littérale vs. Dynamique</h3><p>Une erreur répandue chez les débutants est d’essayer de passer un nombre en utilisant la syntaxe littérale :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- ceci passe une simple chaîne de caractères "1" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Cependant, puisque c’est une prop littérale, sa valeur est passée en tant que simple chaîne de caractères <code>&quot;1&quot;</code> au lieu d’être un nombre. Si nous voulons passer un nombre JavaScript, nous avons besoin d’utiliser <code>v-bind</code> ainsi sa valeur est évaluée en tant qu’expression JavaScript :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- ceci passe un nombre --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Flux-de-donnees-unidirectionnel"><a href="#Flux-de-donnees-unidirectionnel" class="headerlink" title="Flux de données unidirectionnel"></a>Flux de données unidirectionnel</h3><p>Toutes les props forment une liaison <strong>descendante unidirectionnelle</strong> entre la propriété de l’enfant et celle du parent : quand la propriété parente est mise à jour, cela est signalé à l’enfant, mais pas dans l’autre sens. Cela empêche les composants enfants de modifier accidentellement l’état du parent, ce qui rendrait le flux de données de votre application difficile à appréhender.</p>
<p>De plus, chaque fois que le composant parent est mis à jour, toutes les props dans le composant enfant vont être rafraîchis avec les dernières valeurs. Cela signifie qu’il <strong>ne</strong> faut <strong>pas</strong> essayer de changer une prop à l’intérieur d’un composant enfant. Si vous le faites, Vue vous avertira dans la console.</p>
<p>Il y a habituellement deux cas où il est tentant de changer une prop :</p>
<ol>
<li><p>La prop est utilisée uniquement pour passer une valeur d’initialisation, le composant enfant veut simplement l’utiliser par la suite comme une propriété de donnée locale à partir de ce moment ;</p>
</li>
<li><p>La prop est passée comme une valeur brute qui doit être transformée.</p>
</li>
</ol>
<p>Les réponses correctes pour ces cas d’utilisation sont :</p>
<ol>
<li><p>Définir une propriété de donnée locale qui utilise la valeur initiale de la prop comme une valeur d’initialisation :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">props: [<span class="string">'initialCounter'</span>],</div><div class="line"><span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="keyword">this</span>.initialCounter &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Définir une propriété calculée qui est calculée à partir de la valeur de la prop :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">props: [<span class="string">'size'</span>],</div><div class="line"><span class="attr">computed</span>: &#123;</div><div class="line">  <span class="attr">normalizedSize</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p class="tip">Notez que les objets et tableaux en JavaScript sont passés par référence, aussi si la prop est un tableau ou un objet, modifier l’objet ou le tableau lui-même à l’intérieur de l’enfant <strong>va</strong> affecter l’état du parent.</p>

<h3 id="Validation-de-prop"><a href="#Validation-de-prop" class="headerlink" title="Validation de prop"></a>Validation de prop</h3><p>Il est possible pour un composant de spécifier les conditions à remplir pour les props qu’il reçoit. Si une condition n’est pas satisfaite, Vue émettra des alertes. C’est particulièrement utile quand vous créez un composant qui a pour vocation d’être utilisé par d’autres.</p>
<p>Au lieu de définir les props en tant que tableau de chaîne de caractères, vous pouvez utiliser un objet avec des conditions de validation :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'example'</span>, &#123;</div><div class="line">  <span class="attr">props</span>: &#123;</div><div class="line">    <span class="comment">// vérification basique du type (`null` signifie l'acceptation de n'importe quel type)</span></div><div class="line">    propA: <span class="built_in">Number</span>,</div><div class="line">    <span class="comment">// plusieurs types possibles</span></div><div class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</div><div class="line">    <span class="comment">// une chaîne de caractères est obligatoire</span></div><div class="line">    propC: &#123;</div><div class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</div><div class="line">      <span class="attr">required</span>: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// un nombre avec une valeur par défaut</span></div><div class="line">    propD: &#123;</div><div class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</div><div class="line">      <span class="attr">default</span>: <span class="number">100</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// les objets et tableaux par défaut doivent être retournés</span></div><div class="line">    <span class="comment">// par une fabrique de fonctions</span></div><div class="line">    propE: &#123;</div><div class="line">      <span class="attr">type</span>: <span class="built_in">Object</span>,</div><div class="line">      <span class="attr">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// fonction de validation personnalisée</span></div><div class="line">    propF: &#123;</div><div class="line">      <span class="attr">validator</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Le <code>type</code> peut être l’un des constructeurs natifs suivants :</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Function</li>
<li>Object</li>
<li>Array</li>
</ul>
<p>De plus, <code>type</code> peut également être une fonction constructeur personnalisée et ainsi l’assertion sera faite avec une vérification <code>instanceof</code>.</p>
<p>Quand une validation de prop échoue, Vue produira un avertissement dans la console (si vous utilisez le <em>build</em> de développement).</p>
<h2 id="Evenements-personnalises"><a href="#Evenements-personnalises" class="headerlink" title="Événements personnalisés"></a>Événements personnalisés</h2><p>Nous avons appris que le parent peut passer des données à l’enfant en utilisant les props, mais comment allons-nous informer le parent quand quelque-chose survient ? C’est là que le système d’événement personnalisé de Vue entre en jeu.</p>
<h3 id="Utilisation-de-v-on-avec-les-evenements-personnalises"><a href="#Utilisation-de-v-on-avec-les-evenements-personnalises" class="headerlink" title="Utilisation de v-on avec les événements personnalisés"></a>Utilisation de <code>v-on</code> avec les événements personnalisés</h3><p>Chaque instance de Vue implémente une <a href="../api/#Instance-Methods-Events">interface d’événements</a>, cela signifie qu’elle peut :</p>
<ul>
<li>Écouter un événement en utilisant <code>$on(eventName)</code></li>
<li>Déclencher un événement en utilisant <code>$emit(eventName)</code></li>
</ul>
<p class="tip">Notez que le système d’événement de Vue est différent de celui du navigateur <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="external">EventTarget API</a>. Bien qu’il fonctionne de manière similaire, <code>$on</code> et <code>$emit</code> <strong>ne</strong> sont <strong>pas</strong> des alias pour <code>addEventListener</code> et <code>dispatchEvent</code>.</p>

<p>De plus, un composant parent peut écouter des événements émis depuis un composant enfant en utilisant <code>v-on</code> directement sur le template où le composant enfant est utilisé.</p>
<p class="tip">Vous ne pouvez pas utiliser <code>$on</code> pour écouter les événements émis par les enfants. Vous devez utiliser <code>v-on</code> directement dans le template, comme dans l’exemple ci-dessous.</p>

<p>Voici un exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter-event-example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">counter</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span></div><div class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#counter-event-example'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">total</span>: <span class="number">0</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    <span class="attr">incrementTotal</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.total += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>

<div id="counter-event-example" class="demo">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
<script>
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  }
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</script>

<p>Dans cet exemple, il est important de noter que le composant enfant est toujours complètement découplé de ce qui se passe en dehors de celui-ci. Tout ce qu’il fait, c’est rapporter des informations sur sa propre activité, juste au cas où le composant parent écouterait.</p>
<h4 id="Lier-des-evenements-natifs-aux-composants"><a href="#Lier-des-evenements-natifs-aux-composants" class="headerlink" title="Lier des événements natifs aux composants"></a>Lier des événements natifs aux composants</h4><p>Il y a des fois où vous souhaitez écouter un événement natif sur l’élément racine d’un composant. Dans ce cas, vous devez utiliser le modificateur <code>.native</code> sur <code>v-on</code>. Par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">"doTheThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Modificateur-sync"><a href="#Modificateur-sync" class="headerlink" title="Modificateur .sync"></a>Modificateur <code>.sync</code></h3><blockquote>
<p>2.3.0+</p>
</blockquote>
<p>Dans certains cas, nous pourrions avoir besoin d’une « liaison bidirectionnelle » pour une prop. En fait, dans Vue 1.x, c’est exactement ce que le modificateur <code>.sync</code> permettait. Quand un composant enfant mute une prop qui a <code>.sync</code>, la valeur est remontée au parent. C’est pratique, cependant cela peut conduire a des soucis de maintenance sur le long terme car cela brise l’assemption du flux de donnée unidirectionnelle : le code qui mute dans des props enfants affecte l’état du parent.</p>
<p>C’est pour cela que nous avions retiré le modificateur <code>.sync</code> dans la version 2.0. Cependant, nous trouvons tout de même qu’il existe des cas où celle-ci est très utile, nottament pour les composants réutilisables. Ce dont nous avions besoin était <strong>de rendre le code d’un enfant qui affecte l’état d’un parent plus cohérent et explicite.</strong></p>
<p>Dans la 2.3 nous réintroduisons donc le modificateur <code>.sync</code> pour les props, mais cette fois, ce n’est qu’un sucre syntaxique pour étendre automatiquement un écouteur <code>v-on</code> additionnel :</p>
<p>Ce qui suit</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo.sync</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure>
<p>est le raccourci de :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo</span>=<span class="string">"bar"</span> @<span class="attr">update:foo</span>=<span class="string">"val =&gt; bar = val"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Pour un composant enfant qui met à jour la valeur de <code>foo</code>, il faut explicitement emettre un évènement au lieu de muter la prop :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:foo'</span>, newValue)</div></pre></td></tr></table></figure>
<h3 id="Composants-de-champ-de-formulaire-utilisant-les-evenements-personnalises"><a href="#Composants-de-champ-de-formulaire-utilisant-les-evenements-personnalises" class="headerlink" title="Composants de champ de formulaire utilisant les événements personnalisés"></a>Composants de champ de formulaire utilisant les événements personnalisés</h3><p>Les événements personnalisés peuvent aussi être utilisés pour créer des champs personnalisés qui fonctionnent avec <code>v-model</code>. Rappelez-vous :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"something"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>est juste du sucre syntaxique pour :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span></span></div><div class="line">  <span class="attr">v-bind:value</span>=<span class="string">"something"</span></div><div class="line">  <span class="attr">v-on:input</span>=<span class="string">"something = $event.target.value"</span>&gt;</div></pre></td></tr></table></figure>
<p>Quand il est utilisé avec un composant, cela peut être simplifié par :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></div><div class="line">  <span class="attr">:value</span>=<span class="string">"something"</span></div><div class="line">  @<span class="attr">input</span>=<span class="string">"value =&gt; &#123; something = value &#125;"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Donc pour qu’un composant fonctionne avec <code>v-model</code>, il doit :</p>
<ul>
<li>accepter une <code>value</code> prop</li>
<li>émettre un événement <code>input</code> avec la nouvelle valeur.</li>
</ul>
<p>Voyons cela par l’exemple avec une simple saisie de devise :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">v-model</span>=<span class="string">"price"</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'currency-input'</span>, &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">`</span></div><div class="line">    &lt;span&gt;</div><div class="line">      $</div><div class="line">      &lt;input</div><div class="line">        ref="input"</div><div class="line">        v-bind:value="value"</div><div class="line">        v-on:input="updateValue($event.target.value)"&gt;</div><div class="line">    &lt;/span&gt;</div><div class="line">  `,</div><div class="line">  <span class="attr">props</span>: [<span class="string">'value'</span>],</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    <span class="comment">// Au lieu de mettre à jour directement la valeur, cette</span></div><div class="line">    <span class="comment">// méthode est utilisée pour formater et mettre des</span></div><div class="line">    <span class="comment">// contraintes sur la valeur en entrée</span></div><div class="line">    updateValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> formattedValue = value</div><div class="line">        <span class="comment">// Retirer les espaces de part et d'autre</span></div><div class="line">        .trim()</div><div class="line">        <span class="comment">// Tronquer à deux chiffres après la virgule</span></div><div class="line">        .slice(<span class="number">0</span>, value.indexOf(<span class="string">'.'</span>) + <span class="number">3</span>)</div><div class="line">      <span class="comment">// Si la valeur n'est pas déjà dans le bon format,</span></div><div class="line">      <span class="comment">// la réécrire manuellement pour qu'elle le soit</span></div><div class="line">      <span class="keyword">if</span> (formattedValue !== value) &#123;</div><div class="line">        <span class="keyword">this</span>.$refs.input.value = formattedValue</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Émettre la valeur du nombre à travers l'événement input</span></div><div class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="built_in">Number</span>(formattedValue))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>

<div id="currency-input-example" class="demo">
  <currency-input v-model="price"></currency-input>
</div>
<script>
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    updateValue: function (value) {
      var formattedValue = value
        .trim()
        .slice(0, value.indexOf('.') + 3)
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      this.$emit('input', Number(formattedValue))
    }
  }
})
new Vue({
  el: '#currency-input-example',
  data: { price: '' }
})
</script>

<p>L’implémentation ci-dessus est plutôt naïve cependant. Par exemple, les utilisateurs peuvent toujours saisir plusieurs points et même parfois des lettres (beurk) ! Donc pour ceux qui souhaiteraient voir un exemple non trivial, voici un filtre de devise plus robuste :</p>
<iframe width="100%" height="300" src="https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h3 id="Personnalisation-de-composant-avec-v-model"><a href="#Personnalisation-de-composant-avec-v-model" class="headerlink" title="Personnalisation de composant avec v-model"></a>Personnalisation de composant avec <code>v-model</code></h3><blockquote>
<p>Nouveau dans la 2.2.0</p>
</blockquote>
<p>Par défaut, <code>v-model</code> sur un composant utilise <code>value</code> en tant que prop et peuvent vouloir utiliser <code>input</code> en tant qu’événement, mais plusieurs types de champ comme les cases à cocher et les boutons radio pourraient utiliser <code>value</code> pour un usage différent. Utiliser l’option <code>model</code> permet d’éviter les conflits dans ce genre de situations :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'my-checkbox'</span>, &#123;</div><div class="line">  <span class="attr">model</span>: &#123;</div><div class="line">    <span class="attr">prop</span>: <span class="string">'checked'</span>,</div><div class="line">    <span class="attr">event</span>: <span class="string">'change'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">props</span>: &#123;</div><div class="line">    <span class="comment">// ceci permet d'utiliser la prop `value` pour un usage différent</span></div><div class="line">    value: <span class="built_in">String</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-checkbox</span> <span class="attr">v-model</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"une valeur"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></div></pre></td></tr></table></figure>
<p>La partie ci-dessus sera équivalente à :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-checkbox</span></span></div><div class="line">  <span class="attr">:checked</span>=<span class="string">"foo"</span></div><div class="line">  @<span class="attr">change</span>=<span class="string">"val =&gt; &#123; foo = val &#125;"</span></div><div class="line">  <span class="attr">value</span>=<span class="string">"une valeur"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Communication-non-parent-enfant"><a href="#Communication-non-parent-enfant" class="headerlink" title="Communication non parent-enfant"></a>Communication non parent-enfant</h3><p>Parfois deux composants peuvent avoir besoin de communiquer entre eux mais ne sont pas parent et enfant l’un de l’autre. Dans les scénarios simples, vous pouvez utiliser une instance de Vue vide comme canal d’événements central.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue()</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// dans la méthode du composant A</span></div><div class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// dans le hook de création de B</span></div><div class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Dans des cas plus complexes, vous pouvez envisager l’utilisation d’un <a href="state-management.html"><em>pattern</em> de management d’état</a>.</p>
<h2 id="Distribution-de-contenu-avec-des-slots"><a href="#Distribution-de-contenu-avec-des-slots" class="headerlink" title="Distribution de contenu avec des slots"></a>Distribution de contenu avec des slots</h2><p>Quand on utilise des composants, il est souvent souhaitable de les composer comme ceci :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">app</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">app-footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">app</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Il y a deux choses à noter ici :</p>
<ol>
<li><p>Le composant <code>&lt;app&gt;</code> ne sait pas quel contenu peut être présent à l’intérieur de sa cible de montage. Ceci est défini par n’importe quel composant parent qui utilise <code>&lt;app&gt;</code>.</p>
</li>
<li><p>Le composant <code>&lt;app&gt;</code> a vraisemblablement son propre template.</p>
</li>
</ol>
<p>Pour faire fonctionner la composition, nous avons besoin d’un moyen pour entremêler le « contenu » du parent et le template de son propre composant. C’est un processus appelé <strong>distribution de contenu</strong> (ou « transclusion » si vous êtes familier avec Angular). Vue.js implémente une API de distribution de contenu modélisée à partir du brouillon <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="external">brouillon de spécification sur les Web Components</a>, en utilisant l’élément spécial <code>&lt;slot&gt;</code> pour servir de points de distribution pour le contenu original.</p>
<h3 id="Portee-de-compilation"><a href="#Portee-de-compilation" class="headerlink" title="Portée de compilation"></a>Portée de compilation</h3><p>Avant de rentrer plus profondément dans l’API, clarifions dans quelle portée le contenu va être compilé. Imaginez un template comme celui-ci :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span></div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>message</code> devrait-il être lié aux données du parent ou aux données de l’enfant ? La réponse est : au parent. Une règle simple pour la portée du composant est :</p>
<blockquote>
<p>Tout ce qui se trouve dans le template parent est compilé dans la portée du parent ; tout ce qui se trouve dans le template enfant est compilé dans la portée de l’enfant.</p>
</blockquote>
<p>Une erreur répandue est d’essayer de lier une directive à une propriété/méthode enfant dans le template du parent :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- NE fonctionne PAS --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-show</span>=<span class="string">"someChildProperty"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></div></pre></td></tr></table></figure>
<p>En admettant que <code>someChildProperty</code> est une propriété du composant enfant, l’exemple ci-dessus ne fonctionnerait pas. Le template parent n’est pas au courant de l’état du composant enfant.</p>
<p>Si vous avez besoin de lier des directives enfants sur un composant du nœud racine, vous devriez faire cela sur le template du composant enfant :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</div><div class="line">  <span class="comment">// ceci fonctionne, car nous sommes dans la bonne portée</span></div><div class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Enfant&lt;/div&gt;'</span>,</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">someChildProperty</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>De façon similaire, le contenu distribué sera compilé dans la portée parente.</p>
<h3 id="Slot-unique"><a href="#Slot-unique" class="headerlink" title="Slot unique"></a>Slot unique</h3><p>Le contenu parent sera <strong>évincé</strong> si le template du composant enfant contient au moins une balise <code>&lt;slot&gt;</code>. Quand il n’y a qu’un seul slot sans attributs, tout le fragment de contenu sera inséré à sa position dans le DOM, remplaçant le slot lui-même.</p>
<p>Tout ce qui était contenu à la base dans les balises <code>&lt;slot&gt;</code> est considéré comme <strong>du contenu par défaut</strong>. Le contenu par défaut est compilé dans la portée enfant et ne sera affiché que si l’élément l’incluant est vide et qu’il n’y a pas de contenu à insérer.</p>
<p>Supposons que nous ayons un composant appelé <code>my-component</code> avec le template suivant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Je suis le titre de l'enfant<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></div><div class="line">    Ceci ne sera affiché que s'il n'y a pas de contenu</div><div class="line">    à distribuer.</div><div class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Et un parent qui utilise le composant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Je suis le titre du parent<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est le contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est encore du contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Le résultat du rendu sera :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Je suis le titre du parent<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Je suis le titre de l'enfant<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est le contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est encore du contenu original<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Slots-nommes"><a href="#Slots-nommes" class="headerlink" title="Slots nommés"></a>Slots nommés</h3><p>Les éléments <code>&lt;slot&gt;</code> on un attribut spécial, <code>name</code>, qui peut être utilisé pour personnaliser la façon dont le contenu doit être distribué. Vous pouvez avoir de multiples slots avec des noms différents. Un slot nommé ira avec n’importe quel élément possédant l’attribut <code>slot</code> correspondant dans le fragment de contenu.</p>
<p>Il peut encore y avoir un slot non nommé, c’est le <strong>slot par défaut</strong>  qui va servir de fourre-tout pour tout le contenu ne concordant avec aucun nom. S’il n’y a pas de slot par défaut, le contenu ne concordant pas est évincé.</p>
<p>Par exemple, avec un composant <code>app-layout</code> avec le template suivant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Le balisage du parent :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">app-layout</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>Voici un titre de page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Un paragraphe pour le contenu principal.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Et un autre.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>Ici plusieurs informations de contact<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">app-layout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Le résultat du rendu sera :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Voici un titre de page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Un paragraphe pour le contenu principal.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Et un autre.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ici plusieurs informations de contact<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>L’API de distribution de contenu est un mécanisme vraiment utile lors de la conception de composants qui sont censés être composés ensemble.</p>
<h3 id="Slots-avec-portee"><a href="#Slots-avec-portee" class="headerlink" title="Slots avec portée"></a>Slots avec portée</h3><blockquote>
<p>Nouveau dans la 2.1.0</p>
</blockquote>
<p>Un slot avec portée est un type de slot spécial qui fonctionne comme un template réutilisable (auquel on peut passer des données) au lieu d’éléments déjà rendus.</p>
<p>Dans un composant enfant, passez simplement les données via le slot de la même manière que vous passeriez des props dans un composant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">text</span>=<span class="string">"bonjour de l'enfant"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Dans le parent, un élément <code>&lt;template&gt;</code> avec un attribut spécial <code>scope</code> indique que c’est un template pour un slot avec portée. La valeur de <code>scope</code> est le nom de la variable temporaire qui contient l’objet des props passé à l’enfant :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">"props"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>bonjour du parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Si nous faisons le rendu de ce qui précède, la sortie sera :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bonjour du parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>bonjour de l'enfant<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Un cas d’utilisation plus typique des slots avec portée serait un composant de liste qui permettrait à l’utilisateur du composant de personnaliser la manière de faire le rendu de chaque élément de la liste :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-awesome-list</span> <span class="attr">:items</span>=<span class="string">"items"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- le slot avec portée peut également être nommé --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"item"</span> <span class="attr">scope</span>=<span class="string">"props"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"my-fancy-item"</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-awesome-list</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Et le template pour le composant de liste :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item"</span></span></div><div class="line">    <span class="attr">v-for</span>=<span class="string">"item in items"</span></div><div class="line">    <span class="attr">:text</span>=<span class="string">"item.text"</span>&gt;</div><div class="line">    <span class="comment">&lt;!-- contenu par défaut ici --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="Composants-dynamiques"><a href="#Composants-dynamiques" class="headerlink" title="Composants dynamiques"></a>Composants dynamiques</h2><p>Vous pouvez utiliser le même point de montage et dynamiquement permuter entre de multiples composants en utilisant l’élément réservé <code>&lt;component&gt;</code> et en les liant dynamiquement à son attribut <code>is</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#example'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">currentView</span>: <span class="string">'home'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    <span class="attr">home</span>: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">    <span class="attr">posts</span>: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">    <span class="attr">archive</span>: &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- les composants changent quand vm.currentView change ! --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Si vous préférez, vous pouvez aussi les lier directement à des composants objets :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Home = &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;p&gt;Bienvenue chez toi !&lt;/p&gt;'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">'#example'</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">currentView</span>: Home</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><code>keep-alive</code></h3><p>Si vous voulez garder en mémoire les composants à enlever et ainsi préserver son état ou éviter d’en faire le rendu à nouveau, vous pouvez encapsuler un composant dynamique dans un élément <code>&lt;keep-alive&gt;</code> :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- les composants inactifs vont être mis en cache ! --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Obtenez plus de détails sur <code>&lt;keep-alive&gt;</code> dans la <a href="../api/#keep-alive">référence de l’API</a>.</p>
<h2 id="Divers"><a href="#Divers" class="headerlink" title="Divers"></a>Divers</h2><h3 id="Creation-de-composants-reutilisables"><a href="#Creation-de-composants-reutilisables" class="headerlink" title="Création de composants réutilisables"></a>Création de composants réutilisables</h3><p>Lors de la création de composants, il est bon de garder à l’esprit que vous avez l’intention plus tard de les réutiliser ailleurs. Il est acceptable que les composants utilisés qu’une seule fois soient fortement couplés, mais des composants réutilisables doivent définir une interface publique claire et n’émettre aucune hypothèse sur le contexte dans lequel ils sont utilisés.</p>
<p>L’API pour les composants de Vue se découpe en trois parties : les props, les événements et les slots :</p>
<ul>
<li><p>Les <strong>props</strong> permettent à l’environnement extérieur de passer des données dans le composant</p>
</li>
<li><p>Les <strong>événements</strong> permettent au composant de déclencher des effets de bord dans l’environnement extérieur</p>
</li>
<li><p>Les <strong>slots</strong> permettent à l’environnement extérieur de composer le composant avec du contenu additionnel.</p>
</li>
</ul>
<p>les syntaxes abrégées dédiées à <code>v-bind</code> et <code>v-on</code>, l’intention peut être clairement et succinctement communiquée dans le template :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span></span></div><div class="line">  <span class="attr">:foo</span>=<span class="string">"baz"</span></div><div class="line">  <span class="attr">:bar</span>=<span class="string">"qux"</span></div><div class="line">  @<span class="attr">event-a</span>=<span class="string">"doThis"</span></div><div class="line">  @<span class="attr">event-b</span>=<span class="string">"doThat"</span></div><div class="line">&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"main-text"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Les-refs-des-composants-enfants"><a href="#Les-refs-des-composants-enfants" class="headerlink" title="Les refs des composants enfants"></a>Les refs des composants enfants</h3><p>Malgré l’existence des props et des événements, parfois vous aurez toujours besoin d’accéder directement à un composant enfant en JavaScript. Pour parvenir à cela vous pouvez assigner un ID de référence au composant enfant en utilisant <code>ref</code>. Par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">user-profile</span> <span class="attr">ref</span>=<span class="string">"profile"</span>&gt;</span><span class="tag">&lt;/<span class="name">user-profile</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#parent'</span> &#125;)</div><div class="line"><span class="comment">// accès au composant enfant</span></div><div class="line"><span class="keyword">var</span> child = parent.$refs.profile</div></pre></td></tr></table></figure>
<p>Quand <code>ref</code> est utilisé conjointement avec <code>v-for</code>, la référence que vous obtenez sera un tableau ou un objet contenant les composants enfants reflétant la source de donnée.</p>
<p class="tip">Les <code>$refs</code> sont seulement renseignés après le rendu du composant, et ne sont pas réactives. Elles sont seulement destinées à servir de porte dérobée pour la manipulation directe d’enfant (vous devriez éviter d’utiliser <code>$refs</code> dans vos templates et propriétés calculées).</p>

<h3 id="Composants-asynchrones"><a href="#Composants-asynchrones" class="headerlink" title="Composants asynchrones"></a>Composants asynchrones</h3><p>Dans de grosses applications, nous avons parfois besoin de diviser la structure en de plus petits fragments et uniquement charger le composant depuis le serveur quand c’est vraiment nécessaire. Pour rendre ça plus simple, Vue permet de définir votre composant comme une fabrique de fonctions qui résoudra de manière asynchrone la définition de votre composant. Vue déclenchera la fabrique de fonctions uniquement lorsque le rendu du composant est vraiment nécessaire sur le composant et mettra ce rendu en cache pour le resservir lors de futures demandes de rendu. Par exemple :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Passer la définition du composant à la fonction de retour `resolve`</span></div><div class="line">    resolve(&#123;</div><div class="line">      <span class="attr">template</span>: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></div><div class="line">    &#125;)</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>La fabrique de fonctions reçoit une fonction de retour <code>resolve</code> qui devra être appelée quand vous aurez récupéré la définition de votre composant depuis le serveur. Vous pouvez également appeler <code>reject(reason)</code> pour indiquer que le chargement a échoué. La fonction <code>setTimeout</code> est simplement là en tant qu’exemple ; la manière de récupérer le composant est entièrement à votre charge. Une approche recommandée est d’utiliser les composants asynchrones conjointement avec <a href="https://webpack.js.org/guides/code-splitting-require/" target="_blank" rel="external">la fonctionnalité de découpage de code de Webpack</a> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">  <span class="comment">// Cette syntaxe de `require` va indiquer à Webpack</span></div><div class="line">  <span class="comment">// de découper automatiquement votre code après build dans</span></div><div class="line">  <span class="comment">// des bundles qui seront chargés par des requêtes Ajax.</span></div><div class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Vous pouvez également retourner une <code>Promise</code> (promesse) dans la fabrique de fonctions ainsi avec Webpack 2 et la syntaxe ES2015 vous pouvez faire :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(</div><div class="line">  <span class="string">'async-webpack-example'</span>,</div><div class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>Quand vous utilisez une <a href="components.html#Local-Registration">inscription locale</a>, vous pouvez également fournir une fonction qui retourne une <code>Promise</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  components: &#123;</div><div class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p class="tip">Si vous êtes un utilisateur de <strong>Browserify</strong> et que vous souhaitez utiliser ldes composants asynchrones, son créateur a malheureusement <a href="https://github.com/substack/node-browserify/issues/58#issuecomment-21978224" target="_blank" rel="external">été clair</a> sur le fait que le chargement asynchrone « n’est pas quelque chose que Browserify supportera un jour. ». Officiellement, du moins. La communauté Browserify a trouvé <a href="https://github.com/vuejs/vuejs.org/issues/620" target="_blank" rel="external">plusieurs solutions de contournement</a>, qui peuvent être utiles pour des applications complexes déjà existantes. Pour tous les autres scénarios, nous vous recommandons simplement d’utiliser Webpack pour un support de première classe des composants asynchrones, intégré par défaut.</p>

<h3 id="Composants-asynchrones-avances"><a href="#Composants-asynchrones-avances" class="headerlink" title="Composants asynchrones avancés"></a>Composants asynchrones avancés</h3><blockquote>
<p>Nouveau en 2.3.0</p>
</blockquote>
<p>Introduit avec la 2.3, le générateur de composant asynchrone peut aussi retourner un objet au format suivant :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> AsyncComp = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</div><div class="line">  <span class="comment">// Le composant a charger. Il peut être une Promesse (« Promise »)</span></div><div class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComp.vue'</span>),</div><div class="line">  <span class="comment">// Un composant a utiliser pendant que le composant asynchrone se charge</span></div><div class="line">  loading: LoadingComp,</div><div class="line">  <span class="comment">// Un composant a utiliser en cas d'échec de chargement du composant</span></div><div class="line">  error: ErrorComp,</div><div class="line">  <span class="comment">// Délai avant de montrer le composant de chargement (loading). Par défaut à : 200ms.</span></div><div class="line">  delay: <span class="number">200</span>,</div><div class="line">  <span class="comment">// Le composant d'erreur est affiché si la limite d'attente</span></div><div class="line">  <span class="comment">// fixée est dépassée. Par défaut à : Infinity.</span></div><div class="line">  timeout: <span class="number">3000</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Notez qu’en utilisant cela en tant que composant de <code>vue-router</code>, ces propriétés vont être ignorées car les composants asynchrones sont résolue avant que la navigation n’intervienne. Vous pouvez utiliser <code>vue-router</code> 2.4.0+ si vous souhaitez utiliser la syntaxe ci-dessus pour des composants de route.</p>
<h3 id="Conventions-de-nommage-d’un-composant"><a href="#Conventions-de-nommage-d’un-composant" class="headerlink" title="Conventions de nommage d’un composant"></a>Conventions de nommage d’un composant</h3><p>Quand vous inscrivez un composant (ou des props), vous pouvez utiliser la kebab-case, camelCase, ou TitleCase. Vue n’en tient pas rigueur.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// dans une définition de composant</span></div><div class="line">components: &#123;</div><div class="line">  <span class="comment">// inscription utilisant la kebab-case</span></div><div class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">  <span class="comment">// inscription utilisant la camelCase</span></div><div class="line">  <span class="string">'camelCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">  <span class="comment">// inscription utilisant la TitleCase</span></div><div class="line">  <span class="string">'TitleCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>À l’intérieur des templates HTML cependant, vous devez utiliser les équivalences kebab-case :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- toujours utiliser kebab-case dans les templates --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">kebab-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">kebab-cased-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">camel-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">camel-cased-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">title-cased-component</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Quand vous utilisez des template basés sur les <em>chaînes de caractères</em>, vous n’avez pas les restrictions liées à la sensibilité à la casse du HTML. Cela signifie que même dans le template, vous pouvez référencer vos composants et props en utilisant les camelCase, TitleCase, ou kebab-case :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- utilisez ce que vous voulez dans les chaînes de caractères de templates ! --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">myComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">myComponent</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Si votre composant ne passe pas de contenu via des éléments <code>slot</code> vous pouvez même utiliser la syntaxe d’auto-fermeture <code>/</code> après le nom :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>Encore une fois, cela fonctionne <em>seulement</em> dans les templates sous forme de chaîne de caractères. Les éléments auto-fermants ne sont pas du HTML valide et l’analyseur HTML natif de votre navigateur ne le comprendra pas.</p>
<h3 id="Composants-recursifs"><a href="#Composants-recursifs" class="headerlink" title="Composants récursifs"></a>Composants récursifs</h3><p>Les composants peuvent s’invoquer récursivement dans leur propre template. Cependant, ils peuvent uniquement le faire avec l’option <code>name</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">name: <span class="string">'unique-name-of-my-component'</span></div></pre></td></tr></table></figure>
<p>Quand vous inscrivez un composant de manière globale en utilisant <code>Vue.component</code>, l’ID global est automatiquement défini en tant qu’option <code>name</code> du composant.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Si vous n’êtes pas prudent, les composants récursifs peuvent conduire à des boucles infinies :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">name: <span class="string">'stack-overflow'</span>,</div><div class="line"><span class="attr">template</span>: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></div></pre></td></tr></table></figure>
<p>Un composant comme celui ci-dessus conduira à une erreur « taille maximale de pile dépassée »  (“max stack size exceeded”), donc assurez-vous que les invocations récursives soient conditionnelles (c-à-d utilisent un <code>v-if</code> qui vaudra éventuellement <code>false</code>).</p>
<h3 id="References-circulaires-entre-les-composants"><a href="#References-circulaires-entre-les-composants" class="headerlink" title="Références circulaires entre les composants"></a>Références circulaires entre les composants</h3><p>Imaginons que vous construisiez une arborescence de fichiers, comme Finder ou File Explorer. Vous pouvez avoir un composant <code>tree-folder</code> avec ce template :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.children"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Puis un composant <code>tree-folder-contents</code> avec ce template :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>En regardant attentivement, vous verrez que ces composants seront en fait l’ancêtre <em>et</em> le descendant l’un de l’autre dans l’arbre de rendu — un paradoxe ! Quand vous inscrivez un composant de manière globale avec <code>Vue.component</code>, ce paradoxe est résolu pour vous automatiquement. Si c’est votre cas, vous pouvez arrêter de lire ici.</p>
<p>Cependant, si vous réclamez/importez des composants en utilisant un <strong>système de module</strong>, c-à-d via Webpack ou Browserify, vous obtiendrez une erreur « Échec de montage du composant : un template ou une fonction de rendu n’est pas défini. » :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Failed to mount component: template or render function not defined</div></pre></td></tr></table></figure>
<p>Pour expliquer ce qui arrive, je vais appeler nos composants A et B. Le système de module voit de quoi A a besoin, d’abord A a besoin de B, mais B à besoin de A, mais A a besoin de B, etc, etc. Ça tourne en boucle, ne sachant pas comment complètement résoudre l’un ou l’autre des composants sans en résoudre un avant l’autre. Pour régler ça, nous avons besoin de donner au système de module un moyen de dire, « A a <em>éventuellement</em> besoin de B, mais il n’y a pas de raison de résoudre B en premier. ».</p>
<p>Dans notre cas, je ferais cela avec le composant <code>tree-folder</code>. Nous savons que l’enfant crée un paradoxe dans le composant <code>tree-folder-contents</code>, nous allons donc attendre le <em>hook</em> <code>beforeCreate</code> du cycle de vie pour l’inscrire :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Problème résolu !</p>
<h3 id="Templates-avec-inline-template"><a href="#Templates-avec-inline-template" class="headerlink" title="Templates avec inline-template"></a>Templates avec <code>inline-template</code></h3><p>Quand l’attribut spécifique <code>inline-template</code> est présent sur le composant enfant, il va utiliser son contenu interne en tant que template, plutôt que de le traiter comme un contenu distribué. Cela permet une création de template plus flexible.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Ceci est traité comme le template du composant lui-même.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Il n'y aura pas de transclusion de contenu.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Cependant, la propriété <code>inline-template</code> rend la portée de votre template difficile à appréhender. Pour une bonne pratique, optez plutôt pour définir vos templates à l’intérieur du composant en utilisant l’option <code>template</code> ou un élément <code>template</code> dans un fichier <code>.vue</code>.</p>
<h3 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h3><p>Un autre moyen de définir des templates est de le faire à l’intérieur d’un élément <code>script</code> avec le type <code>text/x-template</code>, quand vous référencez le template par son id. Par exemple :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-template"</span>&gt;</span><span class="xml"></span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Bonjour bonjour bonjour<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'#hello-world-template'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Cela peut être pratique pour des démos avec de gros templates ou dans des applications extrêmement petites, mais cela devrait être évité dans tous les autres cas, car cela sépare les templates du reste de la définition du composant.</p>
<h3 id="Composants-statiques-peu-couteux-avec-v-once"><a href="#Composants-statiques-peu-couteux-avec-v-once" class="headerlink" title="Composants statiques peu coûteux avec v-once"></a>Composants statiques peu coûteux avec <code>v-once</code></h3><p>Faire le rendu d’éléments HTML est vraiment rapide avec Vue, mais parfois vous pouvez avoir un composant qui contient <strong>beaucoup</strong> de contenu statique. Dans ces cas, vous pouvez vous assurer qu’il n’est évalué qu’une seule fois puis mis en cache avec la directive <code>v-once</code> sur l’élément racine, comme cela :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">`</span></div><div class="line">    &lt;div v-once&gt;</div><div class="line">      &lt;h1&gt;Conditions d'utilisation&lt;/h1&gt;</div><div class="line">      ... beaucoup de contenu statique ...</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure>

    
      <div class="guide-links">
        
          <span>← <a href="/v2/guide/forms.html">Liaisons sur les champs de formulaire</a></span>
        
        
          <span style="float:right"><a href="/v2/guide/reactivity.html">La réactivité dans le détail</a> →</span>
        
      </div>
    
    <div class="footer">
      Une erreur dans cette page ? Envie de contribuer à la traduction ?
      <a href="https://github.com/vuejs-fr/vuejs.org/blob/master/src/v2/guide/components.md" target="_blank">
        Éditez cette page sur Github !
      </a>
    </div>
</div>

                
            </div>
            <script src="/js/smooth-scroll.min.js"></script>
        

        <!-- main custom script for sidebars, version selects etc. -->        
        <script src="/js/css.escape.js"></script>
        <script src="/js/common.js"></script>

        <!-- search -->
        <link href="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/search.css">
        <script src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
        <script>
        [
          '#search-query-nav',
          '#search-query-sidebar'
        ].forEach(function (selector) {
          if (!document.querySelector(selector)) return
          // search index defaults to v2
          var match = window.location.pathname.match(/^\/(v\d+)/)
          var version = match ? match[1] : 'v2'
          docsearch({
            appId: 'BH4D9OD16A',
            apiKey: '85cc3221c9f23bfbaa4e3913dd7625ea',
            indexName: 'vuejs',
            inputSelector: selector,
            algoliaOptions: { facetFilters: ["version:" + version] }
          })
        })
        </script>

        <!-- fastclick -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script>
        document.addEventListener('DOMContentLoaded', function() {
          FastClick.attach(document.body)
        }, false)
        </script>
    </body>
</html>
